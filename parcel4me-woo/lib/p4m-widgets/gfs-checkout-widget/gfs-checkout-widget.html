<link rel="import" href="../../polymer/polymer.html" />
<link rel="import" href="../../iron-list/iron-list.html" />

<link rel="import" href="../../paper-toggle-button/paper-toggle-button.html" />
<link rel="import" href="../p4m-spinner/p4m-spinner.html" />
<link rel="import" href="../../paper-toast/paper-toast.html" />
<link rel="import" href="../../paper-button/paper-button.html" />
<link rel="import" href="../../paper-tabs/paper-tabs.html" />
<link rel="import" href="../../iron-pages/iron-pages.html" />
<link rel="import" href="../../iron-icons/iron-icons.html" />
<link rel="import" href="../../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../../paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../../paper-item/paper-item.html">
<link rel="import" href="../../paper-listbox/paper-listbox.html">

<link rel="import" href="../gfs-droppoint/gfs-droppoint.html" />
<link rel="import" href="../gfs-droppoint/gfs-location-button.html" />
<link rel="import" href="../gfs-calendar/gfs-calendar.html" />
<link rel="import" href="../map-region-manager/map-region-manager.html" />


<script src="../../momentjs/min/moment.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAMQhcXM06TZBHZ95LwJBRVGSV4CqUQMpI&libraries=places"></script>
<link href="css/custom.css" rel="stylesheet" />
<link href="../gfs-shared/gfs.css" rel="stylesheet" />

<dom-module id="gfs-checkout">
    <!--<link rel="import" type="css" href="custom.css">-->

    <template>     

        <map-region-manager id="regionManager"></map-region-manager>

		<div id="widgetContainer">          
            <paper-tabs selected="{{selectedTab}}" no-bar>           
                <paper-tab>{{calendarDeliveryTitle}}<p4m-spinner species="progress" id="calendar_spinner"></p4m-spinner></paper-tab>
                <paper-tab>Click and Collect<p4m-spinner species="progress" id="clickandcollect_spinner"></p4m-spinner></paper-tab>
                <paper-tab>{{standardDeliveryTitle}}<p4m-spinner species="progress" id="standarddelivery_spinner"></p4m-spinner></paper-tab>
            </paper-tabs>
            <iron-pages id="pages" selected="{{selectedTab}}"  on-iron-select="onSelectTab">           
                <iron-page id="pageCalendar">
                    <div id="calendar-loading" class="loading">
                        <p4m-spinner species="progress" id="calendar-spinner"></p4m-spinner>
                    </div>
                    <div class="pageContent horizontal layout">
                        <gfs-calendar id="calendar" class="flex" on-select-shipping-option="_selectCalendarShippingOption" day-definite-data="{{_data.dayDefinite}}"></gfs-calendar>
                    </div>
                </iron-page>
                <iron-page id="pageDroppoints">
                    <div id="mapTools" class="pageContent">
                        <!-- <div class="header" style="display:none">
                            <h3>{{dropPointTitle}}</h3>
                        </div> -->

                        <div class="toggleDropPointsViewControls">
                            <template is="dom-if" if="{{_showingDroppointsList}}">
                                <a id="viewAsList" on-tap="_toggleDroppointView">
                                <i class="p4micon p4micon-map-with-marker"></i>
                                </a>
                            </template>
                            <template is="dom-if" if="{{_showingDroppointsMap}}">
                                <a id="viewAsList" on-tap="_toggleDroppointView">
                                <i class="p4micon p4micon-list"></i></a>
                            </template>
                        </div>
					
					
                        <div class="location-points">
							<paper-dropdown-menu label="My Locations" noink no-animations>
								<paper-listbox class="dropdown-content">
									    <paper-item >
                                            <gfs-location-button address-name="Current location" on-click="_locateMe" ></gfs-location-button>
                                        </paper-item>

			                            <template is="dom-repeat" items="{{_favAddresses}}">
                                            <paper-item label={{item.name}}>
    			                                <gfs-location-button on-click="_onClickFavAddress" google-api-key="AIzaSyAMQhcXM06TZBHZ95LwJBRVGSV4CqUQMpI" address-name="{{item.name}}" address-data="{{item}}"></gfs-location-button>
                                            </paper-item>
			                            </template>                                    
									
								</paper-listbox>
							</paper-dropdown-menu>
							
                        </div>
						<div class="adjoiner"><p>or</p></div>
                      
                        <div class="search-postcode-wrap">
                            <address-lookup-field id="droppointAddress" on-foundplace="_panToPlace"></address-lookup-field>
                            <div type="submit" class="search-button" on-click="_findPostcode"><iron-icon icon="icons:search"></iron-icon></div>
                        </div>

						<div class="adjoiner"><p>or</p></div>
							<div class="collection-points">
								<paper-dropdown-menu label="My Collection Points" noink no-animations>
									<paper-listbox class="dropdown-content">
									   <template id="mapPreferredDropPointList" is="dom-repeat" items="{{_favDropPoints}}" sort="sortByDistance">
					                     <paper-item label="{{item.droppointDescription}}">
    										<gfs-droppoint on-user-select="_selectFavDropPoint" on-droppoint-selected = "_onDropPointSelectedEvent" container-class="" button-type="tick" disable-unchoose="true" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint>
	                            		 </paper-item>						
									  </template>
								   </paper-listbox>
								</paper-dropdown-menu>
							</div>
                        </div>


                        <div id="list-loading" class="loading">
                            <!-- <p4m-spinner species="shuffler" id="list-spinner"></p4m-spinner> -->
                            <p4m-spinner species="progress" id="list-spinner"></p4m-spinner>
                        </div>


                        <div class="page" id="pageDroppoints">

                        <div id="mapContainer">


                            <div class="hidden" id="hiddenElements">
                                <div id="droppoint_info" class="noscroll">Selected</div>
                                <div id="inspectingDropPointPanel">
                                    <gfs-droppoint id="inspectedDropPoint" droppoint-data="{{_inspectedDropPoint}}" show-shipping-options="false" show-distance="true" show-opening-hours="true"></gfs-droppoint>
                                </div>
                            </div>                          
                            <!--
                               <div id="gfsMapCanvas-loading" class="loading"><paper-spinner id="search-spinner"></paper-spinner></div> 
                            -->
                            <div id="mainMapArea">
                                <div id="gfsMapCanvas">
                                    <div class="loading">
                                        <!-- <p4m-spinner species="shuffler" id="map-spinner"></p4m-spinner> -->
                                        <p4m-spinner species="progress" id="map-spinner"></p4m-spinner>
                                    </div>
                                </div>

                            </div>
                        </div>

                        <array-selector id="dropPointSelector" items="{{_dropPoints}}" selected="{{selected}}" multi="false"></array-selector>
                        <div id="dropPointListContainer" class="hidden">
                            <div class="cardList">                           
                                <div id="mainDropPointListArea">
                                    <div id="dropPointList">
                                        <template id="dropPointListTemplate" is="dom-repeat" items="{{_dropPoints}}" sort="sortByDistance" filter="filterToMap">
                                            <!-- <gfs-droppoint on-droppoint-selected="onDropPointSelectedEvent" show-shipping-options="true" show-opening-hours="true" show-distance="true" button-type="standard" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint> -->
                                            <gfs-droppoint on-droppoint-selected="onDropPointSelectedEvent" show-opening-hours="true" show-distance="true" button-type="standard" droppoint-data="{{item}}" class="droppoint"></gfs-droppoint>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="selectedDropPointPanel" class="hidden" style="height: {{mapHeight}}px; display: block">
                            <gfs-droppoint id="infobox-droppoint" droppoint-data="{{_selectedDropPoint}}" on-droppoint-selected="_onDropPointSelectedEvent" show-shipping-options="true" show-distance="true" show-opening-hours="true"></gfs-droppoint>
                        </div>
                        
                    </div>

                </iron-page>
                <iron-page id="pageStandard">
                    <div id="standard-loading" class="loading">
                        <!-- <p4m-spinner species="shuffler" id="standard-spinner"></p4m-spinner> -->
                        <p4m-spinner species="progress" id="standard-spinner"></p4m-spinner>
                    </div>
                    <ul class="separated">
                        <template id="standardRatesTemplate" is="dom-repeat" items="{{standardRates}}">
                            <li class="gfsStd horizontal layout center">
                                <label for$="{{item.id}}">
                                    <p class="methodname lg">{{item.methodTitle}}</p>
                                    <p class="price lg">{{item.localizedPrice}}</p>
                                    <p class="deliveryDateRange">{{item.deliveryDateRange}}</p>
                                </label>
								<div class="flex"></div>
                                <i name="shipping_method" on-click="setDeliveryMethodEvent" value="{{item.id}}" id="{{item.id}}" class$="p4micon-check-circle link standard-delivery-selection selected_{{item._originalMethodObject.selected}}"></i>
                            </li>
                        </template>
                    </ul>
                </iron-page>
            </iron-pages>
        </div>
        <input type="text" value="{{_selectedDropPoint.droppointId}}" id="dropPointRadio" class="hidden" />
        <paper-toast id="errorNotification" class="fit-bottom"></paper-toast>

        <style include="p4m-shared">
            paper-tab {
                /*border-left: 1px solid rgba(116, 175, 131, 0.15);*/
                border-right: 1px solid rgba(255, 255, 255, .8);
                padding: 0;
            }
            paper-tab:first-of-type {
                border-left: none;
            }
            #dropPointList .content-container {
                padding: 0 0 1em 0;
                margin: .65em 1em;
                border-bottom: 2px solid #eaeaea;
            }
            #inspectingDropPointPanel {
                /*position: absolute;
                top: 327px !important;
                margin-top: -150px;
                left: 0;
                width: 100% !important;
                height: 150px !important;
                z-index: 9999;*/

                background: rgba(255,255,255,0.9) !important;
                padding: 15px !important;
                box-sizing: border-box;
            }
        </style>

    </template>

    <script>
        /* Warning message goes here */
        /*global Polymer*/
        var DAY_MS = 1000 * 60 * 60 * 24;
        var DOW_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', '?'];
        var MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        // element registration
        Polymer({
            is: "gfs-checkout",

            // add properties and methods on the element's prototype

            properties: {
                //=== Element attributes ===//
                accessToken: {
                    type: String
                },

                currencySymbol: {
                    type: String,
                    value: '£'
                },

                config: {
                    type: Object
                },

                preselect: {
                    type: Object,
                    value: true
                },

                useDropPoints: {
                    type: Object,
                    value: true
                },

                useStandard: {
                    type: Object,
                    value: true
                },

                useCalendar: {
                    type: Object,
                    value: true
                },

                calendarLabels: {
                    type: Object,
                    value: {
                        //prev: "<<",
                        //next: ">>",
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        weekdays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                    }
                },

                allowCalendarPreselect: {
                    type: Object,
                    value: true
                },

                defaultTab: {
                    type: String //If 'calendar', shows calendar on startup
                },
/*
                defaultAddress: { //initialAddress
                    type: String
                },*/
               /*
                defaultPostCode: {
                    type: String
                },

                defaultCountryCode: {
                    type: String
                },*/


                // ATTRIBUTES
                //
                // These properties represent text used for labels, titles and prompts throughout the widget.
                // They are controlled by passing values via the element attributes.
                // To override the default values shown below, simply pass through the attributes name, with camel caps converted to dashed lower case:
                // e.g: 'dropPointTitle' would be set by:
                // <gfs-checkout drop-point-title="Your text goes here" ...

                dropPointTitle: {
                    type: String,
                    value: 'Would you prefer to collect your order?'
                },

                dropPointDeliveryTitle: {
                    type: String,
                    value: 'Select your preferred collection point to view available services:'
                },

                calendarDeliveryTitle: {
                    type: String,
                    value: 'Choose your day'
                },

                calendarDayPrompt: {
                    type: String,
                    value: 'Please select a delivery time:'
                },

                standardDeliveryTitle: {
                    type: String,
                    value: 'Standard Delivery'
                },
                
                hideMapUI: {
                    type: Object,
                    value: false
                },

                mapHeight: {
                    type: Number,
                    value: 400
                },

                homeIcon: {
                    type: String
                },

                markerIcon: {
                    type: String
                },

                selectedMarkerIcon: {
                    type: String
                },

                startingZoomLevel: {
                    type: Number,
                    value: 14
                },

                serviceSortOrder: {
                    type: String, //cheapestFirst, fastestFirst, expensiveFirst, slowestFirst
                    value: "cheapestFirst"
                },

                selectedTab: {
                    type: Number,
                    value: 2
                },


                // PRIVATE PROPERTIES
                //
                // Do not modify these properties.


                _suppliedSelection: {
                    type: Object
                },
                selectedServiceDetails: {
                    type: Object,
                    value: {
                        service: null,
                        serviceCode: null,
                        carrier: null,
                        shipping: null,
                        deliveryAddress: null,
                        expDeliveryDateStart: null,
                        expDeliveryDateEnd: null,
                        collectPoint: null
                    }
                },

                standardRates: {
                    type: Array,
                    value: []
                },

                _postData: {
                    type: Object,
                    value: {}
                },

                _autoChooseCollectionPoint: {
                    type: Object,
                    value: true
                },

                _selectedDropPoint: {
                    type: Object
                },

                _inspectedDropPoint: {
                    type: Object
                },             

                _dropPointDetailsClass: {
                    type: String,
                    value: "hidden"
                },

                _shippingRateGroups: {
                    type: Array,
                    notify: true,
                    value: []
                },

                _data: {
                    type: Object,
                    value: {
                        dayDefinite: [],
                        droppoints: [],
                        standardRates: [],
                        links: [],
                        nonDayDefinite: []
                    },
                    notify: true
                },

                _dropPoints: {
                    type: Array,
                    value: [],
                    notify: true
                },

                _favDropPoints: {
                    type: Array,
                    value: []
                },

                _favAddresses: {
                    type: Array,
                    value: [],
                    notify: true
                },

                _map: {
                    type: Object
                },

                _currentMarker: {
                    type: Object
                },

                _dropPointTickClass: {
                    type: String,
                    value: "notchosen"
                },

                _dropPointChooseBtnText: {
                    type: String,
                    value: "Choose"
                },

                _showingDroppoints: {
                    type: Object,
                    value: false
                },

                _showingDroppointsMap: {
                    type: Object,
                    value: true
                },

                _showingDroppointsList: {
                    type: Object,
                    value: false
                },

                _infoWindow: {
                    type: Object
                },

                //Lookup for deliveries on a given day
                _deliveryDays: {
                    type: Object,
                    value: {}
                },

                //Lookup for deliveries on a given day
                _deliveryDroppoints: {
                    type: Object,
                    value: {}
                },

                _earliestDelivery: {
                    type: Object,
                    value: null
                },

            },

            listeners: {
                "datetoggleon": "_deliveryDateSelected",
                "prevmonth": "_calendarMonthChanged",
                "nextmonth": "_calendarMonthChanged"
                //"droppoint-selected": "_onDropPointSelectedEvent"
            },

            // METHODS

            // This function is called as soon as the widget is ready
            ready: function () {
                console.log("GFS Checkout ready", new Date().getTime());
                /*
                if (this.gfsData) {
                    this._postData = JSON.parse(atob(this.gfsData).replace(/\r?\n|\r/g, ""));
                    if (this.autoLoad) {
                        this.postGfsData(function () { });
                    }
                }  */             
            },


            //eeeeeee
            postGfsData: function (callback) {
                this._postReq(this._postData, callback);             
            },

            _makeRequest: function (method, url, callback) {
                if (!callback || typeof (callback) !== "function") {
                    throw "No callback";
                }

                if (this.accessToken === "") {
                    var error =  "No access token";
                    this.$.errorNotification = error;
                    this.$.errorNotification.show();
                    callback(error);
                }
                else {
                    var httpRequest = new XMLHttpRequest();
                    this._showAsLoading(true);

                    httpRequest.open(method, url, true);
                    this._attachHeaders(httpRequest, method);

                    httpRequest.onreadystatechange = (function () {
                        if (httpRequest.readyState !== XMLHttpRequest.DONE) {
                            this._showAsLoading(true);
                        }
                        else {
                            this._showAsLoading(false);
                            try {
                                if (httpRequest.status == 200 || httpRequest.status == 201) {
                                    callback(null, httpRequest.responseText);
                                }
                                else {                               
                                    callback(httpRequest.status, httpRequest.responseText);
                                }                                 
                            }
                            catch (e) {
                                console.error(e.stack);
                                callback(e);
                            }
                        }
                    }).bind(this);                   
                }
                return httpRequest;

            },

            _attachHeaders: function(httpReq, method) {
                var headers = this._computeHeader();
                for (var key in headers) {
                    httpReq.setRequestHeader(key, headers[key]);
                }
                httpReq.setRequestHeader('Content-Type', 'application/json');                
            },

            _computeHeader: function () {
                return {
                    "Authorization": "Bearer " + atob(this.accessToken)
                };
            },

            _postReq: function (data, callback) {
                if (typeof (callback) !== "function") {
                    throw "No callback provided";
                }
                var request = this._makeRequest('POST', "///rest.test.api.checkout.justshoutgfs.com/api/CheckoutSession",
                    (function (err, data) {
                        if (err) {
                            callback(err);
                        }
                        else {
                            this._getReq(data, (function (err) {
                                callback(err);
                            }).bind(this));
                        }
                    }).bind(this)
                );
                request.send(JSON.stringify(data));
            },

            _getReq: function (resourceUrl, callback) {
                var self = this;
                if (typeof (callback) !== "function") {
                    throw "No callback provided";
                }
                this._sessionId = resourceUrl.substring(resourceUrl.lastIndexOf("/") + 1).replace('"','');
                var url = "///rest.test.api.checkout.justshoutgfs.com/api/CheckoutSession/" + this._sessionId;
                var request = this._makeRequest('GET', url, (function (err, data) {

                    console.log("GFS Checkout GET response", new Date().getTime());

                    if (err) {
                        callback(err);
                    }
                    else {
                        var result = JSON.parse(data);
                        if (result.message) {
                            callback(result.message);
                        }
                        else {
                            this.set('_data', JSON.parse(data));
                            this.set('_dropPoints', this._data.droppoints);
                            this._processAllDroppoints();
                            this._requestDroppointList(this._favDropPoints, (function (err) {
                                this._delayedInit.bind(self)();
                                callback(err);
                            }).bind(this));
                        }

                    }
                }).bind(this));
                request.send("");
            },

            _closeReq: function (callback) {
                var data = {
                    closeSession: true,
                    selectedService: this.selectedServiceDetails.serviceId,
                    selectedDroppoint: this.selectedServiceDetails.collectionPoint
                };
                callback(null);

                //Commenting out the below until we know the correct API call
                /*
                var request = this._makeRequest('POST', '///rest.test.api.checkout.justshoutgfs.com/api/CheckoutSession', (function (err, data) {

                    console.log("GFS Checkout Patch response", new Date().getTime());

                    if (err) {
                        callback(err);
                    }
                    else {
                        var result = JSON.parse(data);
                        if (result.message) {
                            callback(result.message);
                        }
                        else {
                            callback(null);
                        }
                    }
                }).bind(this));
                request.send(JSON.stringify(data));*/
            },

            _requestDroppointsByGeoBoxes: function (boxes, callback) {
                var self = this;
                var url = "///rest.test.api.checkout.justshoutgfs.com/api/CheckoutSession?sessionId=" + this._sessionId + "&regions=" + JSON.stringify(boxes);
                var request = this._makeRequest('GET', url, (function (err, data) {
                    var result = JSON.parse(data);
                    if (err || result.message) {
                        callback(err || result.message)
                    }
                    else {
                        if (result.droppoints && result.droppoints.length) {
                            this._dropPoints = this._dropPoints.concat(result.droppoints).sort(this.sortByDistance);
                            this._processAllDroppoints();
                            
                            this._loadDroppointMarkers(this._dropPoints);
                        }
                        callback(null);                     
                    }

                }).bind(this));
                request.send("");
            },

            setGfsOrderValue: function (value) {
                console.log('setGfsOrderValue(' + value + ')');
                this._postData.Request.Order.Value.Value = value;
                //this.postGfsData(callback);
            },

            //Put the address value into the GFS post data
            //TODO: Rename
            setGfsAddress: function (address, autoSelectDelivery, callback) {
                if (typeof (callback) !== "function") {
                    callback = function(){};
                }
                console.log('setGfsAddress(' + JSON.stringify(address) + ')');
                this._postData.Request.Order.Transit.Recipient.Location = address;
                if (autoSelectDelivery) {
                    this.autoSelectDeliveryMethod(callback);
                }
                else callback(null);
            },

            getDeliveryAddress: function() {
                return this._postData.Request.Order.Transit.Recipient.Location
            },

            /*
            setGfsService: function(serviceId) {
                setDeliveryMethod(serviceId);
            },*/

            setFavDropPoints: function (droppointList) {
                this._favDropPoints = droppointList;
                this._processFavDroppoints();
            },

            setFavAddresses: function (addressList) {
                this.set('_favAddresses', addressList);
            },

            selectFavAddress: function (addressId, autoSelectMethod, callback) {
                var self = this;
                var foundItem = self._favAddresses.find(function (item) {
                    return item.id == addressId;
                });
                if (foundItem) {
                    self._unselectDropPoint();
                    
                    self.setGfsAddress(foundItem, autoSelectMethod, callback);
                    /*function (err) {
                        if (err) {
                            callback(err)
                        }
                        else if (autoSelectMethod) {
                            self.autoSelectDeliveryMethod(callback)
                        }
                        else {
                            callback(err);
                        }
                    });*/
                    
                }
                else {
                    callback("Address not found");
                }
            },


            requestDropPointsByAddress: function (addressLine, postCode, countryCode, callback) {
  
                var self = this;
                this._geoCodeAddress(addressLine, postCode, countryCode, function (err, data) {
                    if (!err && data) {
                        var box = [[data.lng() - 0.1, data.lat() - 0.1], [data.lng() + 0.1, data.lat() + 0.1]];
                        self._requestDroppointsByGeoBoxes([box], callback);
                    }
                    else {
                        console.error("Failed to locate address", err);
                        callback(err || "Failed to locate address");
                    }
                })
            },

 
            init: function (config, selection, finalCallback) {
                var self = this;
                this._suppliedSelection = selection;
                var requiredFields = [
                    'countryCode',
                    'postCode',
                    'town',
                    'addressLines',
                    'contactEmail',
                    'recipientFirstName',
                    'recipientLastName',
                    'recipientTitle',
                    'cartValue',
                    'addressPreferences',
                    'deliveryPreferences',
                    'favDropPoints',
                    'favAddresses',
                    'defaultAddress'
                ];
                var missingFields = requiredFields.filter(function (f) {
                    return (typeof (config[f]) == "undefined");
                });
                if (missingFields.length) {
                    throw ("Missing fields: " + missingFields.toString());
                }
                else {
                    this.config = config;

                    //==== Create post data
                    var now = new Date();
                    var maxDate = new Date(now.getTime() + (1000 * 60 * 60 * 24 * 14));
                    




                    this._postData = {
                        "Request":
                        {
                            "DateRange": {
                                "DateFrom": this._makeDateStr(now),
                                "DateTo": this._makeDateStr(maxDate)
                            },
                            "Order": {
                                "Transit": {
                                    "Recipient": {
                                        "Location": {
                                            "CountryCode": {
                                                "Code":  config.countryCode,
                                                "Encoding": "ccISO_3166_1_Alpha2"
                                            },
                                            "Postcode": config.postcode,
                                            "town": config.town,
                                            "addressLineCollection": config.addressLines
                                        },
                                        "contactDetails": {
                                            "Email": config.contactEmail
                                        },
                                        "Person": {
                                            "firstName": config.recipientFirstName,
                                            "lastName": config.recipientLastName,
                                            "title": config.recipientTitle || "Mr"
                                        }
                                    }
                                },
                                "Value": {
                                    "CurrencyCode": "GBP",
                                    "Value": config.cartValue
                                }
                            },
                            "RequestedDeliveryTypes": ["dmDropPoint", "dmStandard"],
                            "Session": {
                                "APIKeyId": "CL-4CE92613-89A6-4248-A573-A9A7333E6A06",
                                "sessionID": ""
                            }
                        }
                    };

                    if (selection && selection.address) {
                        var location = this._postData.Request.Order.Transit.Recipient.Location;
                        location.CountryCode = selection.address.CountryCode,
                        location.Postcode = selection.address.Postcode, 
                        location.town = selection.address.town || "",
                        location.addressLineCollection = selection.address.addressLineCollection
                    }

                    
                    //==== Set fav address data
                    this.setFavDropPoints(this.config.favDropPoints); 
                    this.setFavAddresses(this.config.favAddresses);

                    //if everything has been preselected, preselect,
                    if (selection && selection.deliveryMethodId) {
                        //Post, then try to re-select the chosen method
                        this.postGfsData(function (err) {
                            if (!err) {

                                if (selection.dropPointId) {
                                    self._completeDropPointSelection(selection.dropPointId, selection.deliveryMethodId, finalCallback);
                                }
                                else {
                                    self.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                                    finalCallback();
                                }
                            }
                            else finalCallback(err);
                        });
                    }
                    //Otherwise auto-select address and delivery method according to preferences (if any)
                    else {
                        //Set delivery address first. This will then trigger auto-setting of delivery method

                        this.runDeliveryAddressPreferences(this.config.addressPreferences, this.config.defaultAddress, function (err) {
                            self.postGfsData(function(err) {
                                if (err) {
                                    console.error("postGfsData() returned", err);
                                    finalCallback(err);
                                }
                                else
                                {
                                    self.autoSelectDeliveryMethod(finalCallback);
                                }
                            });
                            //finalCallback(err);
                        });
                    }                 
        
                }
            },

            //TODO
            /*
            applySelection: function(selection) {
                
                //    dropPointId
                //    deliveryMethodId
                //    addressId
                //    deliveryDate
               
                if (selection.dropPointId) {
                    this._completeDropPointSelection(selection.dropPointId, selection.deliveryMethodId);
                }
                else {
                    this.setDeliveryMethod(selection.deliveryMethodId, selection.deliveryDate);
                }
                
            },*/


            //Assuming an address has been chosen, choose a delivery method that best suits the user's preferences:
            //preferSoonest: true/false
            //
            autoSelectDeliveryMethod: function (callback) {
                //If the address chosen is a droppoint,
                //   Get the delivery methods on the droppoint
                //   Choose the most preferred
                //Else if the address chosen isn't a droppoint,
                //   Choose the most preferred standard delivery
                if (!this.standardRates.length) {
                    callback(null); //No delivery methods available yet
                    
                }
                else {
                    if (this.config.deliveryPreferences) {
                        var sortFunction = this._getDeliveryMethodSortFunction();
                        if (this._selectedDropPoint) {
                            //this._selectedDropPoint.deliveries = this._selectedDropPoint.deliveries.sort(sortFunction);
                            //this.set('_selectedDropPoint.deliveryMethod',this._selectedDropPoint.deliveries[0].service.id);
                            //this.setDeliveryMethod();
                            
                            //Can I get away without selecting it via the droppoint widget?
                            this.$['infobox-droppoint'].selectMethod(this._selectedDropPoint.deliveries[0].service.id); //This should send the selection back as a droppoint-selected event
                        }
                        else {
                            this.standardRates = this.standardRates.sort(sortFunction);
                            this.setDeliveryMethod(this.standardRates[0].id);
                            
                        }
                        callback(null);
                    }
                    else {
                        console.warn("No delivery preferences - autoselecting without them");
                        if (this._selectedDropPoint) {
                            this.setDeliveryMethod(this._selectedDropPoint.deliveries[0].service.id);
                        }
                        else {
                            this.setDeliveryMethod(this.standardRates[0].id);
                        }
                        callback(null);
                    }
                   
                }

            },

            //Assuming a delivery method has been chosen, choose a delivery address
            autoSelectDeliveryAddress: function (serviceDetails) {
                //If it's a standard delivery method, choose default fav address
                //newSelectedServiceDetails
                if (serviceDetails.serviceType.type == "dmStandard") {
                    this.setGfsAddress(this.config.defaultAddress);
                }
                else {
                    //If it's a droppoint delivery method....?
                    //TODO
                }



               
            },

            //Select a delivery address based on the users preferences
            runDeliveryAddressPreferences: function(prefs, defaultAddress, finalCallback) {

                //Select address based on preferences
                var defaultPrefs = ["useMyDeliveryAddress", "useMyDropPoints", "useRetailerDropPoint"];
                if (!prefs || prefs.constructor !== Array) {
                    console.log("runDeliveryAddressPreferences: using default", defaultPrefs);
                    prefs = defaultPrefs;
                }

                //Preferred address
                //Process a priority list of address preferences
                var self = this;
                var handlers = {
                    "useMyDeliveryAddress": function (callback) { self.setGfsAddress(defaultAddress, true, callback); },
                    "useMyDropPoints": function (callback) { self.selectNearestFavDropPoint(callback); },
                    "useRetailerDropPoint": function (callback) { self.selectNearestDropPoint(callback); }
                };
                var handlerArray = [];
                prefs.forEach(function (pref) {
                    handlerArray.push(handlers[pref]);
                });

                function runHandler(index) {
                    handler = handlerArray[index || 0];
                    if (handler) {
                        //console.log("Running handler", index);
                        handler(function (err, data) {
                            //console.log("Handler returned", err);
                            if (err) {
                                runHandler(index + 1);
                            }
                            else {
                                finalCallback();
                            }
                        });
                    }
                    else {
                        finalCallback();
                        //console.log("Finished running handlers");
                    }
                }

                runHandler(0);

            },

            _preselectForCalendar: function () {
                //this.$.calendar.autoSelect();
            },

            //TODO: Change to use _originalShippingService.selected
            _preselectForStandard: function () {
                /*
                //TODO This function needs to change
                if (this.standardRates) {
                    //this.set('_selectedDropPoint', null);
                    this._unselectDropPoint();
                    var preselectedService = this.standardRates[0];
                    if (!preselectedService.selected) {
                        preselectedService.selected = true;
                    }                   
                    
                    this.setDeliveryMethod(preselectedService.id, preselectedService.deliveryDate);
                    this.set('standardRates', JSON.parse(JSON.stringify(this.standardRates)));
                    this.$.standardRatesTemplate.render();
                    //this.fire('selectedservicechanged', this.selectedServiceDetails);//.standardRates[0]);
                    //this.fire('preselectedservice', this.selectedServiceDetails);
                }*/

            },

            //Select a delivery service
            //TODO: Refactor?
            setDeliveryMethod: function (methodId, dateOverride) {

                if (!methodId) {
                    debugger;
                    return;
                }


                var newMethod = this._getDeliveryRateById(methodId);
                if (!newMethod) {
                    debugger;
                    console.error("Method not available");
                    this.fire('noservice');
                    return;
                }

                else {
                    //The original service object is attached directly to selectedServiceDetails, allowing us to deselect it directly
                    if (this.selectedServiceDetails && this.selectedServiceDetails._originalMethodObject) {
                        this.selectedServiceDetails._originalMethodObject.selected = false;
                    }

                    newMethod.selected = true;
                    if (!newMethod.price) {
                        debugger;
                    }

                    var newSelectedServiceDetails = {
                        _originalMethodObject: newMethod,
                        serviceId: methodId,
                        service: newMethod.methodTitle,
                        serviceCode: newMethod.carrierCode,
                        carrier: newMethod.carrierName,
                        shipping: newMethod.price,
                        currencySymbol: this.currencySymbol
                    }

                    if (dateOverride) {
                        newSelectedServiceDetails.expDeliveryDate = moment.utc(dateOverride).toISOString();
                        this.$.calendar.selectShippingOption(methodId, dateOverride, true);
                    }
                    else {
                        newSelectedServiceDetails.expDeliveryDate = moment.utc(newMethod.deliveryTimeTo).add(newMethod.maxDD - newMethod.minDD, 'days').toISOString();
                    }

                    if (newMethod.serviceType.type == "dmStandardDropPoint" && this._selectedDropPoint) {
                        newSelectedServiceDetails.collectionPoint = this._selectedDropPoint.droppointId;
                        newSelectedServiceDetails.providerId = this._selectedDropPoint.providerId;
                        newSelectedServiceDetails.provider = this._selectedDropPoint.providerName;
                        newSelectedServiceDetails.deliveryAddress = this._selectedDropPoint.geoLocation;
                        this.set('_selectedDropPoint.deliveryMethod', methodId);
                    }
                    else {

                        //If we have selected something other than a droppoint, and we previously had a droppoint selected,
                        //We need to unselected it and then auto-select a standard address
                        if (this._selectedDropPoint) {
                            this._unselectDropPoint(); //If unselect a droppoint, default back to a fav address
                            this.autoSelectDeliveryAddress(newMethod); //This is a reference to the original delivery method object                           
                        }
                        else {
                            //We had a standard address selected already, apparently. 
                            //So we don't need to autoselect one.
                            console.log("Not selecting a standard address automatically.")
                        }
                        newSelectedServiceDetails.deliveryAddress = this.getDeliveryAddress();
                    }
                    this.set('selectedServiceDetails', newSelectedServiceDetails);
                  

                    this.set('standardRates', this._getStandardServices());

                    //this.set('standardRates', JSON.parse(JSON.stringify(this.standardRates)));
                    //this.set('dayDefinite', JSON.parse(JSON.stringify(this.dayDefinite)));
                    //this.set('standardRates', JSON.parse(JSON.stringify(this.standardRates)));

                    this.$.standardRatesTemplate.render();
                    this.fire('selectedservicechanged', this.selectedServiceDetails);
                    return this.selectedServiceDetails;
                }
            },


            
            selectNearestFavDropPoint: function(callback) {
                if (this._favDropPoints.length) {
                    this._selectDropPoint(this._favDropPoints[0].droppointId, callback);
                }
                else {
                    callback("No favourite drop-points");
                }
            },

            selectNearestDropPoint: function(callback) {
                this.requestDropPointsByAddress(this.config.defaultAddress.Street1, this.config.defaultAddress.PostCode, null, function (dropPoints) {
                    if (dropPoints && dropPoints.length) {
                        var dropPoint = dropPoints[0];
                        this._selectDropPoint(dropPoint.droppointId, callback);
                    }
                    else {
                        callback("No supported drop-points found");
                    }
                });
            },

            //This runs after the GFS requests have returned data
            _delayedInit: function () {
                this._processRateData();

                if (this.useDropPoints) {
                    this._makeMap();
                    this._findPostcode();
                    this._processAllDroppoints();
                    this.panToDefaultLocation();
                }

               //this.processRates();

                //this.showPage_Standard();
            },

            //Index and tidy GFS rate data
            _processRateData: function () {
                if (this._data.nonDayDefinite.constructor === Array && this._data.nonDayDefinite.length > 0) {
                    this._data.standardRates = this._getStandardServices();
                    this.set('standardRates', this._data.standardRates);
                    //console.log(this.standardRates);
                }
                this.notifyPath('_data.dayDefinite'); //??? Needed?
            },

            _showAsLoading: function (loading) {

                if (loading) {
                    this.$$('#list-spinner').active = "true";
                    this.$$('#standard-spinner').active = "true";
                    this.$$('#list-loading').classList.remove('hidden');
                    this.$$('#standard-loading').classList.remove('hidden');
                    this.$$('#calendar-loading').classList.remove('hidden');
                }
                else {
                    this.$$('#list-spinner').active = null;
                    this.$$('#standard-spinner').active = null;
                    this.$$('#list-loading').classList.add('hidden');
                    this.$$('#standard-loading').classList.add('hidden');
                    this.$$('#calendar-loading').classList.add('hidden');
                }
            },


            sortByDistance: function (a, b) {
                if (a.selected) return -1
                else if (b.selected) return 1
                else if (a === b) return 0;
                else return a.distanceInMeters < b.distanceInMeters ? -1 : 1;
            },

            filterToMap: function (item) {
                if (this._map) {
                    if (this._mapViewPort) {
                        var sw = { longitude: this._mapViewPort[0][0], latitude: this._mapViewPort[0][1] };
                        var ne = { longitude: this._mapViewPort[1][0], latitude: this._mapViewPort[1][1] };

                        if ((item.geoLocation.coordinates.latitude > sw.latitude && item.geoLocation.coordinates.latitude < ne.latitude)
                            && (item.geoLocation.coordinates.longitude > sw.longitude && item.geoLocation.coordinates.longitude < ne.longitude)) {
                            return true;
                        }
                        else {
                            return false;
                        }                      
                    }
                    else return true;
                }
                else {
                    return true;
                }              
            },
            /*
            getClosestDroppoint: function (dpList) {
                return dpList.reduce(function (prev, curr) {
                    return (prev.distanceMeters < curr.distanceInMeters) ? prev : curr;
                });
            },*/

            _getDeliveryMethodSortFunction: function() {

                if (this.config.deliveryPreferences.preferSoonest) {
                    return (
                        function(a, b) {
                            if (a && b) {
                                return a.deliveryTimeFrom || a.deliveryDate < b.deliveryTimeFrom || a.deliveryDate ? 1 : -1;
                            }
                            else {
                                console.warn("Sorting by deliveryDate: invalid parameter: ", a, b);
                                return 1;
                            }
                            
                        }
                    );
                }
                else {
                    return (
                        function(a, b) {

                            if (a && b) {
                                if (a.service && b.service) {
                                    aPrice = a.service.price;
                                    bPrice = a.service.price;
                                }
                                else {
                                    aPrice = a.price;
                                    bPrice = b.price;
                                }  
                                return aPrice > bPrice? 1 : -1;
                                                            
                            }
                            else {
                                console.warn("Sorting by price: invalid parameter: ", a, b);
                                return 1;
                            }
                           
                        }
                    );
                }
            },
            
            _processAllDroppoints: function () {
                this._removeDupDropPoints();
                this._addDropPointDeliveries();
                this._sortDropPointServices();
                this._processFavDroppoints();
                this._indexDropPointProviders(this._data.dayDefinite);
                this._indexDropPointProviders(this._data.nonDayDefinite);
            },

            _removeDupDropPoints: function () {
                var self = this;
                var uniques = [];
                for (var j = 0; j < this._dropPoints.length; j++) {
                    var dp = this._dropPoints[j];
                    if (!uniques.find(function(item) {
                        return item.droppointId == dp.droppointId;
                    })) {
                        uniques.push(dp);
                    }
                }
                this.set('_dropPoints', uniques);
            },

            _sortDropPointServices: function() {
                if (this.config.deliveryPreferences) {
                    var sortFunction = this._getDeliveryMethodSortFunction();
                    this._dropPoints.map(
                        function(item) {
                            if (item.deliveries && item.deliveries.length) {
                                item.deliveries = item.deliveries.sort(sortFunction);
                            }                           
                        });
                    
                }
            },

            _addDropPointDeliveries: function () {
                var self = this;
                this._dropPoints.map(
                    function (item) {

                        item.collectionPoint = true;
                        item.deliveries = self._findDropPointDeliveries(item.providerId);
                        return item;
                    }
                );
            },

            _processFavDroppoints: function()
            {
                //Now replace preferred items with real data
                var self = this;
                this._favDropPoints = this._favDropPoints.map(function (item) {
                    var existingItem = self._droppointById(null, item.droppointId);
                    if (existingItem) {
                        existingItem.selected = item.selected;
                    }
                    return existingItem || item;
                }).sort(this.sortByDistance);
            },
            
            _makeMap: function () {
                var self = this;

                var home = null;
                console.log("Infowindow = ", self.$.droppoint_info);
                self._infoWindow = new google.maps.InfoWindow({
                    //TIP: To use dynamic content here, use "droppoint_info" as shown in comment below. Then place a droppoint widget or similar into the droppoint_info element.
                    content: "Selected" //self.$.droppoint_info
                });
                var position = new google.maps.LatLng(37, 0);

                // map options
                var mapOptions = {

                    // initial zoom level
                    zoom: self.startingZoomLevel,
                    minZoom: self.startingZoomLevel - 2,

                    // initial center position
                    center: position,

                    // type of map (ROADMAP, SATELLITE, TERRAIN, HYBRID)
                    mapTypeId: google.maps.MapTypeId.TERRAIN,

                    // show or hide streetview control
                    streetViewControl: false,

                    // show or hide the google map UI
                    disableDefaultUI: self.hideMapUI,

                    // map controls (only if disableDefaultUI is false)
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                    },

                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle.SMALL,
                        position: google.maps.ControlPosition.TOP_RIGHT
                    },

                    // remove points of interest from the map so as not to interfere
                    styles: [{
                        "featureType": "poi",
                        "elementType": "labels",
                        "stylers": [{
                            "visibility": "off"
                        }]
                    }]
                };

                //var postcode = document.getElementById('shipping:postcode').value; //Improve selection method

                self._map = new google.maps.Map(self.$.gfsMapCanvas, mapOptions);
                window.map = self._map;            

                // 'idle' event is triggered when the user stopped zooming/dragging;
                google.maps.event.addListener(self._map, 'idle', function (event) {
                    //console.log(JSON.stringify(event));
                    //console.log('MAP EVENT idle');
                    self._mapMoved();
                });

                google.maps.event.addListener(self._map, 'click', function (event) {
                    //console.log('MAP EVENT click');
                    //self._unselectDropPoint();
                });

                google.maps.event.addListener(self._map, 'center_changed', function (event) {
                    //console.log('MAP EVENT center_changed');
                    //self._unselectDropPoint();
                });

            },

            _loadDroppointMarkers: function (dropPointsArray) {
                var self = this;
                if (!dropPointsArray) return;
                //=== Drop point markers
                var marker;
                dropPointsArray.forEach(
					function (pointItem) {
					    var getCountryCode = pointItem.geoLocation.countryCode;
					    var markerConfig = {
					        position: new google.maps.LatLng(pointItem.geoLocation.coordinates.latitude, pointItem.geoLocation.coordinates.longitude),
					        map: self._map,
					        //animation: google.maps.Animation.DROP,
					        //title: pointItem.droppointDescription,
					        customData: pointItem,
					        icon: self._droppointIcon(getCountryCode) + '/' + pointItem.providerName + '.png',
					        zIndex: google.maps.Marker.MAX_ZINDEX + 1
					        //icon: url + '/' + pointItem.geoLocation.countryCode + '/' + pointItem.providerName + '.png'
					    };
					    //console.log(pointItem.geoLocation.coordinates.longitude, pointItem.geoLocation.coordinates.latitude);
					    marker = new google.maps.Marker(markerConfig);
					    marker.addListener('click', function (clickedMarker) {
					        self._selectDropPointMarker(this);
					    });
                        marker.addListener('mouseover', function(inspectedMarker) {
                            var latlng = this.getPosition();
                            self._inspectDropPointMarker(this);
                        });
                        marker.addListener('mouseout', function() {
                            self._hideDropPointInspector();
                        });
					    // add a link to the marker to get to it from the droppoint, need to animate and centre the marker if selecting from list view
					    pointItem.marker = marker;
					}
				);
                this.$.dropPointListTemplate.render();

            },

            _droppointIcon: function(countryCode) {
                var url = this.resolveUrl('./images/');
                if (!countryCode) {
                    return url;
                }
                else {                
                    switch (countryCode) {
                    case "DE":
                        return url + '/DE/';
                    case "FR":
                    case "BE":
                    case "ES":
                        return url + '/FR/';
                    default:
                        return url + '/GB/';
                    }
                }
            },

            _onPostcodeSearchKeyDown: function (e) {
                //console.log(e);
                if (e && e.key && e.key === 'Enter') {
                    this._findPostcode();
                }
                else {
                    this._delayedPostcodeSearch();
                }
            },

            _delayedPostcodeSearch: function () {
                if (this._searchTimeout) {
                    window.clearTimeout(this._searchTimeout);
                }
                this._searchTimeout = window.setTimeout(this._findPostcode.bind(this), 300);
            },

            // Geocode service search
            _findPostcode: function () {
                if (this._searchTimeout) {
                    window.clearTimeout(this._searchTimeout);
                }
                var self = this;
                var postcode = this.$.droppointAddress.value || this.postCode;
                //self.initialAddress = address;
                //self.$$("#gfsMapCanvas-loading").classList.remove('hidden');

                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({
                    componentRestrictions: {
                        country: this.countryCode,
                        postalCode: postcode
                    }
                }, function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {

                        self._panToGeoLocation({ lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() });

                        marker = new google.maps.Marker({
                            map: self._map,
                            icon: self._getHomeIcon(),
                            position: results[0].geometry.location
                        });
                    }

                    else {
                        /*
                        console.log('Google Maps API ERROR - Geocode was not successful for the following reason: ' + status);
                        self.$$("#gfsMapCanvas-loading").classList.add('hidden');
                        self.$.errorNotification.text = "Postcode not found";
                        self.$.errorNotification.fitInto = self.$.gfsMapCanvas;
                        self.$.errorNotification.open();
                        */
                    }
                });
            },


            _geoCodeAddress: function (streetAddress, postCode, countryCode, callback) {
                var addressStr = streetAddress + "," + postCode;
                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({
                    componentRestrictions: {
                        country: countryCode || this.countryCode
                    },
                    address: addressStr
                },
                function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        if (results && results.length) {
                            var geoLocation = results[0].geometry.location;
                            callback(null, geoLocation);
                        }
                    }
                    else {
                        callback("No results");
                    }
                });
            },

            _mapMoved: function() {
                var self = this;
                if (self._moveMapTimeout) {
                    window.clearTimeout(self._moveMapTimeout);
                }
                self._moveMapTimeout = window.setTimeout((function() {
                    self._reloadDroppoints();
                }).bind(this), 100);

            },

            // used for trouble shooting
            _drawBoxes: function(boxes, color) {
                var self = this;
                boxes.forEach(function(rect) {
                    var boxCoords = [{
                        lat: rect[0][1],
                        lng: rect[0][0]
                    }, // north west
                        {
                            lat: rect[0][1],
                            lng: rect[1][0]
                        }, // south west
                        {
                            lat: rect[1][1],
                            lng: rect[1][0]
                        }, // south east
                        {
                            lat: rect[1][1],
                            lng: rect[0][0]
                        } // north east
                    ]

                    self._map.data.setStyle({
                        fillColor: color,
                        strokeColor: color,
                        strokeWeight: 2
                    });
                    self._map.data.add({
                        geometry: new google.maps.Data.Polygon([boxCoords])
                    });
                });
            },

            _updateMapViewPort: function() {
                var bounds = this._map.getBounds();
                if (!bounds) {
                    console.error("Failed to get map bounds");
                    return;
                }          
                var northEast = [bounds.getNorthEast().lng(), bounds.getNorthEast().lat()];
                var southWest = [bounds.getSouthWest().lng(), bounds.getSouthWest().lat()];
                if (northEast[0] === southWest[0] && northEast[1] === southWest[1]) return;
                this._mapViewPort = [southWest, northEast];
            },

            _updateUi: function() {
                //Display/hide things based on the current state

                if (this._selectedDropPoint) {
                    this.$.selectedDropPointPanel.classList.remove("hidden");
                }
                else {
                    this.$.selectedDropPointPanel.classList.add("hidden");
                }
                this.$.dropPointListTemplate.render(); //Re-sort the list of drop point cards
            },

            
            _reloadDroppoints: function() {
                if (this._sessionId) {
                    //console.log('reloadDroppoints()');

                    //Get viewport rectangle
                    this._updateMapViewPort();
                    if (!this._mapViewPort) return;

                    var boxes = [];
                    
                    this.$.regionManager.getUncoveredRectangles(this._mapViewPort).forEach(function (rect) {
                        boxes.push(rect.toGeoBox());
                    });

                    // console.log('Boxes to request:', JSON.stringify(boxes));
                    // self._drawBoxes(boxes, 'green');
                    
                    if (boxes.length > 0 && this._mapViewPort) {
                        this.$.regionManager.addRegion(this._mapViewPort);
                        this._requestDroppointsByGeoBoxes(boxes, function () { });
                    }
                    else {
                        console.log("Not requesting any regions");
                    }

                    
                    this._resetMap(this._map);
                }
            },

            _requestDroppointList: function (droppointList, callback) {
                //NOTE: This is temporary code, to be replaced by a dedicated API endpoint
                if (droppointList.length === 0) {
                    callback();
                }
                else {
                    var self = this;

                    //Make array of geoBoxes, tightly encompassing each droppoint
                    var boxes = [];
                    droppointList.forEach(function (dp) {
                        boxes.push([[dp.geoLocation.coordinates.longitude - 0.000001, dp.geoLocation.coordinates.latitude - 0.000001], [dp.geoLocation.coordinates.longitude + 0.000001, dp.geoLocation.coordinates.latitude + 0.000001]]);
                    });
                    this._requestDroppointsByGeoBoxes(boxes, callback);
                }

            },



            _showDropPointDetails: function() {
                this.mapHeight = this.$.gfsMapCanvas.clientHeight;
                this._dropPointDetailsClass = "fade-in";
            },

            _toggleDroppointView: function() {
                this._showingDroppointsList = !this._showingDroppointsList;
                this._showingDroppointsMap = !this._showingDroppointsMap;
                this._showDropPointsView();
            },

            _showDropPointsView: function () {
                var self = this;
                //this.fire('show-droppoints');
                if (this._showingDroppointsMap) {
                    //Show droppoints
                    this.$.dropPointListContainer.classList.add('hidden');
                    this.$.mapContainer.classList.remove('hidden');
                    //this._makeMap();
                    this._loadDroppointMarkers(this._dropPoints);                                                                           
                    this._resetMap(this._map, function() {
                        self._openSelectedDropPointInfoWindow();
                    });
                    //this.panToDefaultLocation();

                }
                else {
                    this.$.dropPointListContainer.classList.remove('hidden');
                    this.$.mapContainer.classList.add('hidden');
                    //this._resetMap(this._map);
                    //this._openSelectedDropPointInfoWindow();
                }

            },

            _resetMap: function (map, callback) {
                var self = this;
                if (map) {
                    window.setTimeout(function () {
                        google.maps.event.trigger(map, 'resize');
                        if (callback) callback();
                        
                    }, 100);
                }           
            },

            _getHomeIcon: function() {
                if (this.homeIcon) {
                    return this.homeIcon;
                } else {
                    return this.resolveUrl('./images/home.png');
                }
            },

            //Select a droppoint
            /*
            selectDropPoint: function (dropPointId) {
                //Select the drop point, if it is known.
                var dp = this._droppointById(null, dropPointId);
                if (!dp) {
                    return "No such droppoint";
                }
                else {
                    //Unselect the old droppoint (if any)
                    this._unselectDropPoint();
                    

                    //Select this by setting it to selected and assigning _selectedDropPoint
                    //dp.selected = true;
                    this.set("_selectedDropPoint", dp);
                    this.set("_selectedDropPoint.selected", true);
                }
            },

            _unselectDropPoint: function() {
                if (this._selectedDropPoint) {
                    if (this._infoWindow) {
                        this._infoWindow.close();
                    }
                    this._hideDropPointDetails();
                    this._selectedDropPoint = null;
                }
            },
            */

            _openSelectedDropPointInfoWindow: function () {
                if (this._showingDroppointsMap && this._selectedDropPoint) {
                    var dp = this._droppointById(this._selectedDropPoint.providerId, this._selectedDropPoint.droppointId);
                    
                    if (dp) {
                        if (this._currentMarker == dp.marker) return;
                        else this._currentMarker = dp.marker;
                    }
                    /*
                    else {
                        console.error("Droppoint not found", this._selectedDropPoint.droppointId);
                         //Make a marker
                        this._loadDroppointMarkers([this._selectedDropPoint]);
                        this._currentMarker = this._selectedDropPoint.marker; //this._droppointById(this._selectedDropPoint.providerId, this._selectedDropPoint.droppointId).marker;
                    }*/
                    //console.log("### Opening info box");
                   
                    this.$.dropPointRadio.setAttribute('checked', 'true');
                    this._map.panTo(this._currentMarker.getPosition());
                    var self = this;
                    this._infoWindow.open(self._map, self._currentMarker);

                }
            },


            //=== Received event from droppoint widget, indicating that a delivery method from a droppoint has been chosen
            //Note that this doesn't fire just when a droppoint is clicked on, or when selected is set to true;
            //To fire, it must be selected AND a delivery method chosen.
            //
            //Make this droppoint the 'selected' one, and open the info window
            _onDropPointSelectedEvent: function (e) {
                if (!e.detail.deliveryMethod) {
                    console.log("No delivery method chosen.");
                }

                //.if (this._selectedDropPoint && this._selectedDropPoint.droppointId == e.detail.droppointId) return; //Already selected
                //If there is no method, _completeDropPointSelection will choose one for us
                var self = this;
                //Get selected delivery method
                this._completeDropPointSelection(e.detail.droppointId, e.detail.deliveryMethod, function () {

                    //Show on the map, pop up the info window
                    self._openSelectedDropPointInfoWindow();
                    self._updateUi();

                });

            },

            //==== Make this droppoint the 'selected' one
            //If no method chosen, auto-choose one
            _completeDropPointSelection: function(droppointId, methodId, callback) {
                if (!callback) { callback = function () { }; }

                var self = this;
                if (methodId && (methodId == this.selectedServiceDetails.serviceId && this.selectedServiceDetails.collectionPoint == droppointId) ) {
                    
                    //this.setDeliveryMethod(methodId); //?
                    callback(null); 
                } 
                //if (false) {} 
                else {

                    var dp = this._droppointById(null, droppointId)            
                    this.set("_selectedDropPoint", dp);
                    this.set("_selectedDropPoint.selected", true);
                    //this.set("_selectedDropPoint.deliveryMethod", methodId);

                    if (methodId) {    
                        //If we're selecting a new droppoint and/or method,
                        

                        this.$['infobox-droppoint'].select();
                        this.$['infobox-droppoint'].selectMethod(methodId, true);      
                        this.setDeliveryMethod(methodId);    

                        self._updateUi(); 
                        //self._runningCompleteDropPointSelection = false;      

                        callback(null);
                    }
                 
                    else {
                        this.autoSelectDeliveryMethod(function (err) {
                            
                            self._updateUi();
                            //this._runningCompleteDropPointSelection = false;
                            callback(err);
                        });
                    }
                }
               
            },



            _selectDropPoint(dropPointId) {
                var self = this;
                this._completeDropPointSelection(dropPointId, null, function () {
                    self.$['infobox-droppoint'].select(); //The gfs-droppoint widget will fire droppoint-selected 
                    //Next stop _onDropPointSelectedEvent() 
                })
            },

            //=== Select a drop point marker
            //Make it the 'selected' one
            //Select the infobox's gfs-droppoint widget.
            _selectDropPointMarker: function (marker) {
                var dp = this._droppointById(null, marker.customData.droppointId);

                //marker.setIcon(this._droppointIcon() + 'gmap-icon-selected-shadow.png');
                this._selectDropPoint(marker.customData.droppointId);
            },

            _inspectDropPointMarker: function (marker) {
                var dp = this._droppointById(null, marker.customData.droppointId);
                this._inspectDropPoint(dp, marker);
            },

            _inspectDropPoint: function (dp, marker) {
                this._hideDropPointInspector();

                this._inspectDropPointTimeout = window.setTimeout((function() {
                    this.set('_inspectedDropPoint', dp);
                    this.$.inspectedDropPoint.buildWeekCollection();
                    this._hideDropPointInspector();


                    this._customInfoBox = new InfoBox({
                        latlng: marker.getPosition(),
                        map: this._map,
                        content: this.$.inspectingDropPointPanel
                    });       
                }).bind(this), 350);


            },

            _hideDropPointInspector: function() {
                if (this._inspectDropPointTimeout) {
                    window.clearTimeout(this._inspectDropPointTimeout);
                    delete this._inspectDropPointTimeout;
                }
                if (this._customInfoBox) {
                    this._customInfoBox.remove();

                    this._customInfoBox = null;
                    this.set('_inspectedDropPoint', null);
                }
            },


            _selectFavDropPoint: function(e) {
                this._selectDropPoint(e.target.droppointData.droppointId);
            },

            _unselectDropPoint: function () {
                if (this._selectedDropPoint) {
                    if (this._infoWindow) {
                        this._infoWindow.close();
                    }
                    //this._hideDropPointDetails();
                    this._updateUi();
                    this._selectedDropPoint = null;
                }
            },
           
            _droppointById: function (providerId, droppointId) {
                if (!this._dropPoints) {
                    return;
                }
                for (var i = 0; i < this._dropPoints.length; i++) {
                    if (/*(this._dropPoints[i].providerId === providerId) && */(this._dropPoints[i].droppointId === droppointId)) {
                        return this._dropPoints[i];
                    }
                }
            },

            _locateMe: function() {
                var self = this;
                // Try HTML5 geolocation.
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            var pos = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            self._panToGeoLocation(pos);
                        },
                        function(err) {
                           console.error(JSON.stringify(err));
                        }
                    );
                } 
                else {
                    console.error("Browser does not support geolocation");

                }
            },

            setMapHome: function (location) {
                /*
                var homeMarkerConfig = {
                    position: location,
                    map: this._map,
                    //animation: google.maps.Animation.DROP,
                    title: 'Home',
                    html: 'Home',
                    icon: this._getHomeIcon()
                };
                marker = new google.maps.Marker(homeMarkerConfig);*/
                //this._map.setCenter(homeMarkerConfig.position);
            },

            panToDefaultLocation: function () {
                var self = this;
                if (this._postData.Request.Order.Transit.Recipient.Location) {
                    var location = this._postData.Request.Order.Transit.Recipient.Location;
                    this._geoCodeAddress(location.addressLineCollection[0], location.Postcode, location.CountryCode.Code, function (err, data) {
                        if (err) {
                            console.error('panToDefaultLocation():', err);
                        }
                        else {
                            var geoLocation = {
                                lat: data.lat(),
                                lng: data.lng()
                            };

                            self._panToGeoLocation(geoLocation);
                            self.setMapHome(geoLocation);
                        }

                    });

                }
                else if (this._favAddresses.length) {
                    if (this._favAddresses[0].geoLocation.coordinates.latitude && this._favAddresses[0].geoLocation.coordinates.longitude) {
                        var geoLocation = {
                            lat: this._favAddresses[0].geoLocation.coordinates.latitude,
                            lng: this._favAddresses[0].geoLocation.coordinates.longitude
                        };
                        this._panToGeoLocation(geoLocation);
                    }
                }
            },


            _makeDateStr: function(d) {
                function pad(n, padSize) {
                    var str = n.toString();
                    var padZeros = (new Array(padSize)).join('0');
                    return (padZeros + str).substr(-padSize);
                }
                return (
                    pad(d.getFullYear(), 4) + '-' +
                    pad(d.getMonth() + 1, 2) + '-' +
                    pad(d.getDate(d), 2)
                );
            },

            _selectCalendarShippingOption: function (e) {
                //console.log('Updating delivery options with', e.detail.shippingMethodId, e.detail.deliveryDate);
                this.setDeliveryMethod(e.detail.shippingMethodId, e.detail.deliveryDate);
            },

            _formatDayDefiniteDate: function(deliveryDate) {
                return '(Est. arrival: ' + moment(deliveryDate).format("ddd, Do MMM") + ')';
            },

            _formatNonDayDefiniteDate: function(startDate, endDate) {
                return '(Est. arrival: ' + moment(startDate).format("ddd, Do MMM") + ' - ' + moment(endDate).format("ddd, Do MMM") + ')';
            },

            _findDropPointDeliveries: function(providerId) {
                var self = this;
                //var droppointIndex = providerId;
                if (typeof (this._deliveryDroppoints[providerId]) !== "undefined") {
                    var results = [];
                    for (var service in this._deliveryDroppoints[providerId]) {
                        var item = this._deliveryDroppoints[providerId][service];
                        /*var obj = {
                            id: item.service.id,
                            methodTitle: item.service.methodTitle,
                            price: item.service.price,
                        };*/
                        if (item.service.maxDD == item.service.minDD) {
                            // day definite
                            var startDate = new Date(item.deliveryDate);
                            item.deliveryDateRange = this._formatDayDefiniteDate(startDate);
                        }
                        else {
                            // non day definite
                            var startDate = new Date(item.deliveryDate);
                            var endDate = new Date(startDate);
                            endDate.setDate(endDate.getDate() + (item.service.maxDD - 1));
                            item.deliveryDateRange = this._formatNonDayDefiniteDate(startDate, endDate);
                        }
                        results.push(item);
                    }
                    return results;
                } else {
                    return null;
                }
            },

            //Make a lookup for droppoint providers, allowing all shipping methods for that provider to be returned
            _indexDropPointProviders: function (deliveryDayArray) {
                var self = this;
                //For each item in the array of delivery days,
                deliveryDayArray.forEach(function (day) {
                    //For each rate on the day,
                    day.rates.forEach(function (service) {
                        //If this is a droppoint,
                        if (service.serviceType.type === "dmStandardDropPoint") {
                            //For each droppoint provider that covers this droppoint,
                            service.serviceType.droppointProviders.forEach(function (provider) {                              
                                //If this is a provider not yet seen, instantiate with a blank object
                                if (typeof (self._deliveryDroppoints[provider.id]) === "undefined") {
                                    self._deliveryDroppoints[provider.id] = {};
                                }
                                //If this is a service not known for this provider, add it    
                                if (typeof(self._deliveryDroppoints[provider.id][service.id]) === "undefined") {
                                    self._deliveryDroppoints[provider.id][service.id] = {
                                        deliveryDate: day.deliveryDate,
                                        service: service
                                    };
                                }
                                //Else if this is a known service for this provider,
                                else {
                                    //If this new one has an earlier delivery date, use that one
                                	var oldDay = new Date(self._deliveryDroppoints[provider.id][service.id].deliveryDate);
                                	var thisDay = new Date(day.deliveryDate);
                                	if (oldDay.getTime() > thisDay.getTime()) {
                                        self._deliveryDroppoints[provider.id][service.id] = {
                                            deliveryDate: day.deliveryDate,
                                            service: service
                                        };
                                    }
                                }
                            });
                        }
                    });
                });
            },

            // find the earliest of each non-day-definite service
            _getStandardServices: function () {
                var self = this;
                var results = [];
                var services = {};




                //For each non day definite item,
                this._data.nonDayDefinite.forEach(function (day) {
                    //For each rate on the day,
                    day.rates.forEach(function (serviceItem) {
                        //If this is a standard rate,
                        if (serviceItem.serviceType.type === "dmStandard") {
                            //If this is a provider not yet seen, instantiate 
                            if (typeof (services[serviceItem.id]) === "undefined") {
                                services[serviceItem.id] = {
                                    deliveryDate: day.deliveryDate,
                                    service: serviceItem
                                };
                            }                         
                            //If this new one has an earlier delivery date, use that one
                            var oldDay = new Date(services[serviceItem.id].deliveryDate);
                            var thisDay = new Date(day.deliveryDate);
                            if (oldDay > thisDay) {
                                services[serviceItem.id].deliveryDate = day.deliveryDate;
                            }
                            services[serviceItem.id].selected = services[serviceItem.id].selected || serviceItem.selected;
                        }
                    });
                });

                //Now convert the index into an array
                for (var service in services) {
                    var item = services[service];
                    var obj = {
                        id: item.service.id,
                        methodTitle: item.service.methodTitle,
                        price: item.service.price,
                        localizedPrice: item.service.localizedPrice,
                        _originalMethodObject: item.service
                    };
                    // non day definite
                    var startDate = new Date(item.deliveryDate);
                    var endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + (item.service.maxDD - 1));
                    obj.deliveryDateRange = this._formatNonDayDefiniteDate(startDate, endDate);
                    obj.deliveryTimeFrom = endDate.getTime();
                    results.push(obj);
                }

                if (this.config.deliveryPreferences) {
                    var sortFunction = this._getDeliveryMethodSortFunction();
                    results = results.sort(sortFunction);
                }

                return results;
            },

            
            _getDeliveryRateById: function (id) {
                var combinedRateGroups = this._data.dayDefinite.concat(this._data.nonDayDefinite);
                var rates = [];
                combinedRateGroups.forEach(function (group) {
                    rates = rates.concat(group.rates);
                });
                var resultList = rates.filter(function (rate) {
                    return rate.id == id
                });
                if (resultList.length) {
                    return resultList[0];
                }
                else return null;
            },


            _unselectMethod: function() {
                var methods = this.standardRates;
                methods.forEach(function (item) {
                    item.selected = false;
                });
            },

          
            setDeliveryMethodEvent: function (e) {
                //if (e.target.checked) {                    
                    this.setDeliveryMethod(e.target.id);
                //}
            },

            onSelectTab: function (e) {
                if (e.detail.item.id === "pageCalendar") {
                    this.onShowPage_Calendar();
                }
                else if (e.detail.item.id === "pageStandard") {
                    this.onShowPage_Standard();
                }
                else if (e.detail.item.id === "pageDroppoints") {
                    this.onShowPage_Droppoints();
                }
                else {
                }
            },

            showPage_Calendar: function() {              
                this.$.pages.select(0);
                this.onShowPage_Calendar();              
            },

            onShowPage_Calendar: function(preselect) {
                this.showingDroppoints = false;

            },

            showPage_Standard: function (preselect) {
                this.$.pages.select(2)           
			},

			onShowPage_Standard: function(preselect) {
			    this.showingDroppoints = false;
  			    this.$.standardRatesTemplate.render();
			},

            showPage_Droppoints: function () {
                this.$.pages.select(1);
                this.onShowPage_Droppoints();
            },

            onShowPage_Droppoints: function() {
            	if (this._map) {
                    this.showingDroppoints = true;
                    this._showDropPointsView();
                }
            },

			showView_DroppointsList: function() {

			},

			_onClickDroppoint: function (e) {

			},

			_onClickFavAddress: function (e) {
                //this.$.favAddressDropDown.text = "Hello";
			    this._panToGeoLocation(e.currentTarget.geoLocation);
			},
            /*
			_onSelectFavDroppoint: function (dp) {
			    var geoLocation = {
			        lat: dp.currentTarget.droppointData.geoLocation.coordinates.latitude,
			        lng: dp.currentTarget.droppointData.geoLocation.coordinates.longitude
			    };
			    this._panToGeoLocation(geoLocation);
			},*/

			_panToGeoLocation: function (geoLocation) {
                this._map.panTo(geoLocation);
                this._mapViewPort = [[ geoLocation.lng - 0.01,geoLocation.lat - 0.01], [geoLocation.lng + 0.01, geoLocation.lat + 0.01]];
			},

			_panToPlace: function (e) {
			    this._panToGeoLocation(e.detail.geometry.location);
            }

        });

        function isNull(a, b) {
            if (a == null || typeof (a) == "undefined" || a == "" || a.length == 0) return b
            else return a;
        }


        /* An InfoBox is like an info window, but it displays
         * under the marker, opens quicker, and has flexible styling.
         * @param {GLatLng} latlng Point to place bar at
         * @param {Map} map The map on which to display this InfoBox.
         * @param {Object} opts Passes configuration options - content,
         * offsetVertical, offsetHorizontal, className, height, width
         */

        function InfoBox(opts) {
            google.maps.OverlayView.call(this);
            this.latlng_ = opts.latlng;
            this.map_ = opts.map;
            this.content = opts.content;
            this.contentOrigin = this.content.parentNode;
            this.offsetVertical_ = -195;
            this.offsetHorizontal_ = 5;
            //this.height_ = 165;
            this.width_ = 240;

            this.setMap(this.map_);
        }
        /* InfoBox extends GOverlay class from the Google Maps API
         */
        InfoBox.prototype = new google.maps.OverlayView();
        /* Creates the DIV representing this InfoBox
         */
        InfoBox.prototype.remove = function () {
            if (this.content) {
                this.contentOrigin.appendChild(this.content);
            }
            this.setMap(null);
        };
        /* Redraw the Bar based on the current projection and zoom level
         */
        InfoBox.prototype.draw = function () {
            // Creates the element if it doesn't exist already.
            this.createElement();
            if (!this.content) return;
            // Calculate the DIV coordinates of two opposite corners of our bounds to
            // get the size and position of our Bar
            var pixPosition = this.getProjection().fromLatLngToDivPixel(this.latlng_);
            if (!pixPosition) return;

            var posX = pixPosition.x + this.offsetHorizontal_;
            var posY = pixPosition.y + this.offsetVertical_ + 85;//- (this.height_/2);

            // Now position our DIV based on the DIV coordinates of our bounds
            this.content.style.width = this.width_ + "px";
            this.content.style.left = (posX - 32) + "px";
            this.content.style.height = this.height_ + "px";
            this.content.style.top = (posY + 70) + "px";
            this.content.style.display = 'block';
            this.content.style.position = 'relative';
            
            this.content.style['z-index'] = 99;
        };

        InfoBox.prototype.createElement = function () {
            var panes = this.getPanes();
            panes.floatPane.appendChild(this.content);
        }

    </script>
</dom-module>