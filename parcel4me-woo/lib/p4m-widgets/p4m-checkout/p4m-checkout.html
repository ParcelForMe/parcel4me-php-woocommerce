
<link rel="import" href="../../polymer/polymer.html" />

<link rel="import" href="../../polymer-cookie/polymer-cookie.html" />
<link rel="import" href="../../paper-tabs/paper-tabs.html" />
<link rel="import" href="../../iron-pages/iron-pages.html" />

<link rel="import" href="../p4m-spinner/p4m-spinner.html" />
<link rel="import" href="../p4m-shared/p4m-shared.html" />
<link rel="import" href="../p4m-profile/p4m-profile.html" />
<link rel="import" href="../p4m-api/p4m-api.html" />
<link rel="import" href="../p4m-cart/p4m-cart.html" /> 
<link rel="import" href="../p4m-order-summary/p4m-order-summary.html" />
<link rel="import" href="../p4m-address-list/p4m-address-list.html" />
<link rel="import" href="../p4m-purchase/p4m-purchase.html" />
<link rel="import" href="../p4m-purchase/p4m-purchase-btn.html" />
<link rel="import" href="../p4m-card-list/p4m-card-list.html" />
<link rel="import" href="../p4m-delivery/p4m-delivery.html" />
<link rel="import" href="../p4m-order-text/p4m-order-text.html" />

<link rel="import" href="../p4m-discount-input/p4m-discount-input.html" />
<link rel="import" href="../p4m-discount-list/p4m-discount-list.html" />

<link rel="import" href="../gfs-checkout-widget/gfs-checkout-widget.html" />
<link rel="import" href="../address-lookup-field/address-lookup-field.html" />  

<link rel="import" href="../p4m-imports/p4m-imports.html" />  
 
<link rel="stylesheet" href="../p4m-shared/p4m.css" />

<dom-module id="p4m-checkout">

    <template>
        <p4m-api id="p4mCheckoutApi" ssl="true" host-base-domain="parcelfor.me" host-type="{{hostType}}" version="v2"></p4m-api>
        <p4m-api id="localApi" is-local="true"></p4m-api>
        <div id="container" class$="{{_changeIndicatorClass}}">

            <div id="topPanel" class="topPanel">
                <img class="p4m-register-logo" src="../p4m-shared/img/P4M-Top-Header.png" id="peli-icon-header" />
                <!-- Not using due to Variable font baselines screwing alignment across browsers, Including in logo image instead.
                <h2>Checkout &amp; Delivery</h2> -->
                <div class="flex-spacer"></div>
                <div><span class="font-weight-light">Welcome,</span> </div>
                <p4m-profile mode="basic"></p4m-profile>
            </div>

            <div id="panelContainer" class="horizontal layout">
                <div id="detailPanel" class="p4m-panel flex-2">                   
                    <paper-tabs selected="{{selectedTab}}" no-bar>
                        <paper-tab>My Order<p4m-spinner species="progress" id="myorder_spinner"></p4m-spinner></paper-tab>
                        <paper-tab>Addresses<p4m-spinner species="progress" id="addresses_spinner"></p4m-spinner></paper-tab>
                        <paper-tab>Delivery Options<p4m-spinner species="progress" id="delivery_spinner"></p4m-spinner></paper-tab>
                        <paper-tab>Payment Options<p4m-spinner species="progress" id="payment_spinner"></p4m-spinner></paper-tab>                  
                    </paper-tabs>
                    <iron-pages id="p4mPages" selected="{{selectedTab}}" on-iron-select="_onSelectTab">                   
                        <iron-page id="cartPage">                       
                            <p4m-cart id="cart" cart-data="{{cartData}}"></p4m-cart>                         
                        </iron-page>
                        <iron-page id="addressPage">
                            <p4m-address-list id="addressList" address-list-data="{{consumerData.addresses}}" cart-data="{{cartData}}" on-select="onSelectAddressFromList" on-add="onAddAddress" on-update="onUpdateAddress"></p4m-address-list>
                        </iron-page>
                        <iron-page id="deliveryPage">
                            <gfs-checkout id="gfsCheckoutWidget" on-session-expiry="onGfsSessionExpiry" access-token="{{gfsAccessToken}}"  on-selectedservicechanged="onGfsServiceChanged" on-noservice="onGfsNoService" delivery-preferences="{{deliveryPreferences}}" consumer-addresses="{{consumerData.addresses}}" ></gfs-checkout>
                            <template is="dom-if" if="{{_notUseGfsCheckout}}">
                                <p4m-delivery></p4m-delivery>
                            </template>
                            <template is="dom-if" if="{{useGfsCheckout}}">
                            </template>
                        </iron-page>
                        <iron-page id="cardPage">
                            <p4m-card-list id="cardList" consumer-data="{{consumerData}}" cart-data="{{cartData}}" on-selected="onSelectPaymentMethod" on-gotnewcard="onGotNewCard"></p4m-card-list>
                        </iron-page>

                    </iron-pages>                 
                </div>
                <div id="summaryPanel" class="p4m-panel smallSummary flex-1">
                    <p4m-order-summary id="orderSummary" cart-data="{{cartData}}"></p4m-order-summary>                     
                    <p4m-purchase id="p4mPurchase" cart-data="{{cartData}}" on-payment-complete="onPaymentComplete" on-request-payment-method="goToPaymentMethods" use-paypal="{{usePaypal}}" selected-card="{{selectedCard}}" use-paypal="true"></p4m-purchase>
                </div>
            </div> 


            <footer id="footerpPanel" class$="footerPanel {{_changeIndicatorClass}}">
                
                <p4m-order-text cart-data="{{cartData}}" consumer-data="{{consumerData}}" on-request-address="goToAddresses"></p4m-order-text>
                <p4m-purchase-btn id="p4mPurchaseBtn"></p4m-purchase-btn>
            </footer>

        </div>

        <polymer-cookie id="sessionCookie" name="CartId"></polymer-cookie>
        <!--             
        <polymer-cookie id="p4mDefaultPostCode" name="p4mDefaultPostCode"></polymer-cookie>
        <polymer-cookie id="p4mDefaultCountry" name="p4mDefaultCountry"></polymer-cookie>
        -->

        <style include="p4m-shared">
            .litte-spinner {
                width: 20px;
                height: 20px;
                position: relative;
                xtop: 65px;
                xleft: 40%;
                margin-left: auto;
            }
            paper-tab {
                border-right: 1px solid rgba(255,255,255,0.2);
                padding: 0;
            }
            paper-tab:first-of-type {
                border-left: none;
            }
        </style>

    </template>





    <script>

        Polymer({
            is: "p4m-checkout",

            properties: {
                sessionId: {
                    type: String
                },
                consumerData: {
                    type: Object,
                    notify: true
                    //observer: "onConsumerDataChange"
                },              
                cartData: {
                    type: Object,
                    notify: true,
                },
                isNew: {
                    type: Object,
                    value: false
                },
                deliveryData: {
                    type: Object,
                    notify: true
                },
                selectedTab: {
                    type: Number,
                    value: 0
                },
                currency: {
                    type: String,
                    value: "GBP"
                },
                selectedCard: {
                    type: Object
                },
                hostType:{
                    type: String,
                    value: "dev" //default value
                },
                useGfsCheckout: {
                    type: Object,
                    value: false
                },
                usePaypal: {
                    type: Object,
                    value: false,
                    notify: true
                },
                gfsAccessToken: {
                    type: String
                },
                gfsData: {
                    type: String
                },
                initialPostCode: {
                    type: String,
                    value: "W1A 0AX"
                },
                initialCountryCode: {
                    type: String,
                    value: "GB"
                },
                onSessionExpiry: {
                    type: String
                },
                _notUseGfsCheckout: {
                    type: Object,
                    value: true
                },
                _changeTimer: {
                    //Timer object to allow sending of changes once user has finished interaction
                    type: Object
                },
                _changeIndicatorClass: {
                    type: String,
                    value: "not_changed"
                },
                _loadingStack: {
                    type: Number,
                    value: 0
                }
                
            },
            observers: [
                //"onCartDiscountChange(cartData.discounts.*)"
               "onCartItemsChange(cartData.items.*)"
               //"onConsumerAddressChange(consumerData.addresses.*)"
            ],

            ready: function()
            {
                console.log("P4M Checkout ready", new Date().getTime());
                //console.log('Async:',async);
                var self = this;
                this.Tabs = { "ORDER": 0, "DELIVERY": 1, "PAYMENT": 2, "ADDRESS": 3 };
                this._notUseGfsCheckout = !this.useGfsCheckout;

                if (!this.sessionId) {
                    this.sessionId = this.$.sessionCookie.readCookie();
                }

                this.init();




                /*
                if (this.sessionId) {
                    this.getLocalCart();
                }

                this.$.p4mCheckoutApi.call('consumer', null, null, function (data) {
                    self.onConsumerData(data);
                    self.preselectAddress();
                    self.preselectDeliveryMethod();
                });*/
            },

            init: function (finalCallback) {
                var self = this;
                self.initialising = true;
                console.log('Initialising...');
                self.sessionAddressId = hashThis(this.sessionId);
                async.series(
                    [
                        function _consumer(callback) {
                            self._getConsumer(callback)
                        },

                        //Get local cart
                        function _localCart(callback) {
                            console.log('_localCart()');
                            if (self.sessionId) {
                                self.getLocalCart(function (err) {
                                    if (err) {
                                        callback(err)
                                    }
                                    else {
                                        self.updateP4mCart(callback);
                                    }
                                });
                            }
                            else {
                                callback("No cart");
                                //self.getP4mCart(callback);
                            }
                        },
                        /*
                        function _setAddress(callback) {
                            if (self.isNew) {
                                self.preselectAddress(callback)                                
                            }

                            else 
                                callback(null);
                        }*/
                    ],
                    function (err) {

                        if (err) {
                            self.initialising = false;
                            console.error(err);
                            console.log('...Initialisation aborted.');
                            throw err;
                        }

                        async.series(
                        [
                            /*
                            function _newCart(callback) {
                                console.log('_newCart()');
                                //If this is a new cart, preselect as much as possible.
                                //Otherwise, the user has already selected their options.

                                //self.isNew = true;
                                if (!self.cartData.AddressId) {
                                    self.preselectAddress(callback);
                                    
                                    callback(null);
                                }
                                else {
                                    callback(null);
                                }
                            },*/

                            //Send info from cart and consumer to GFS
                            function _gfs(callback) {
                                self.initialising = false;
                                console.log('_gfs()');
                                if (self.$.gfsCheckoutWidget) {
                                    self._updateGfs(callback);
                                }
                                else {
                                    callback(null);
                                }
                            },

                            function _p4mCart(callback) {
                                //self.initialising = true;
                                
                                console.log('_p4mCart():self.updateP4mCart() start');
                                //self.preselectDeliveryMethod();

                                self.updateP4mCart(function(err) {//This will set IsNew to false
                                    //self._updateGfs(callback); //Try to fill out delivery method
                                    console.log('_p4mCart():self.updateP4mCart() complete');
                                    callback(err);
                                }); 
                            }
                        ],
                        function (err) {
                            if (err) {
                                console.error(err);
                                console.error("Cancelled initialisation.");
                            }
                            self.initialising = false;
                            console.log('...Initialisation complete.');
                        })
                    }
                )
            },

            _getConsumer: function (callback) {
                var self = this;
                if (!callback)
                    callback = function () { };


                self.$.p4mCheckoutApi.call('consumer', null, null, function (err, data) {
                    if (!data.success) {
                        callback(data.error);
                    }
                    else {
                        self.set('consumerData', data.consumer);
                        callback(err, data);
                    }
                });
            },


            //Send all cart information to shipping plugin
            _updateGfs: function (callback) {

                var self = this;

                var orderValue = 0.0;
                this.cartData.items.forEach(function (item) {
                    orderValue += item.qty * item.price;
                });
                var addrPrefs = this.consumerData.deliveryPreferences ? this.consumerData.deliveryPreferences.split(',') : null;
                var gfsPostConfig = {
                    countryCode: null,
                    town: "London",
                    Town: "London",
                    postCode: null,
                    addressLines: [],
                    contactEmail: "nocontact@nocontact.com",
                    recipientFirstName: this.consumerData.familyName,
                    recipientLastName: this.consumerData.givenName,
                    recipientTitle: this.consumerData.title || "",
                    favDropPoints: self._getPreferredDropPoints() || [],
                    favAddresses: self._getPreferredAddresses() || [],
                    defaultAddress: p4mAddressToGfsAddress(self.getAddressById(this.consumerData.prefDeliveryAddressId)),
                    cartValue: orderValue,
                    addressPreferences: addrPrefs,
                    deliveryPreferences: {
                        preferSoonest: this.consumerData.preferSoonestDelivery
                    }


                };

                //Make an object containing everything needed for GFS Checkout to re-select my previous delivery options
                var selection = null;
                if (!this.isNew) {
                    selection = {
                        dropPointId: self.getAddressById(self.cartData.addressId).dropPointId,
                        deliveryMethodId: self.cartData.serviceId,
                        address: p4mAddressToGfsAddress(self.getAddressById(self.cartData.addressId)) || null,
                        deliveryDate: new Date(self.cartData.expDeliveryDate)
                    }
                    //selection = null;
                }
                this.toggleLoading(true);
                this.$.gfsCheckoutWidget.init(gfsPostConfig, selection, function(err) {
                    self.toggleLoading(false);
                    callback(err);
                });

            },

            debug: function(e) {
                console.log("p4m-checkout debug", this.cartData);
            },

            getLocalCart: function (callback) {
                var self = this;
                this.$.localApi.call('getP4MCart', null, null, function (err, data) {
                    if (err) {
                        console.log("getLocalCart() error:", err);
                        callback(err);
                    }
                    else {
                        self.isNew = data.isNew;
                        self.cartData = data.cart;
                        callback(err, data.cart);
                    }
                });
            },

            getP4mCart: function (callback) {
                this.$.p4mCheckoutApi.call('currentCart', { sessionId: this.sessionId }, null, this.onRemoteCartData.bind(this, callback));
            },

            sendCartItemChanges: function () {          
                //Send changes to local API, then to P4m
                var self = this;
                var changes = [];

                for (var sku in this.$.cart.changes) {
                    if (this.$.cart.changes[sku] === "" || this.$.cart.changes[sku] === null) {
                        this.$.cart.changes[sku] = 0;
                    }
                    changes.push({ItemCode: sku, Qty: this.$.cart.changes[sku]});
                }
                if (changes.length > 0) {
                    
                    var orderValue = 0.0;
                    for (var item in this.$.cart.items) {
                        orderValue += item.qty * item.price; 
                    }

                    //this.$.gfsCheckoutWidget.setGfsOrderValue(orderValue, function () {
                    //self._showAsLoadingShipping(true);
                    self.toggleLoading(true);

                    self.$.localApi.call('itemQtyChanged', {}, changes, function (err, newCartTotals) {
                        //console.log("Called local api itemQtyChanged");
                        console.log("sendCartItemChanges(): itemQtyChanged: new cart totals", newCartTotals);
                        self.$.cart.clearChanges();
                        self.updCartTotals(newCartTotals, function (err) { //This will trigger GFS to trigger updateP4mCart, so no need to call it in the callback here. Commented out.
                            self.toggleLoading(false);
                            self.cartData.discounts = newCartTotals.discounts;
                            /*self.updateP4mCart(function(err) {
                                self.toggleLoading(false);
                                //callback(err);
                            });*/
                            
                        });

                    });
                    //})

                }
                else {
                    //console.log("No changes to send");
                }
            },

            //Send new total to shipping module and ask for new shipping price etc
            updCartTotals: function (newCartTotals, callback) {
                this.cartData.tax = newCartTotals.tax;
                this.cartData.shippingAmt = newCartTotals.shipping;
                this.cartData.total = newCartTotals.total;

                if (this.$.gfsCheckoutWidget) {
                    this._updateGfs(callback);              
                }
                else {
                    callback(null);
                }
            },

            _showAsLoadingShipping: function(loading) {
                this.$.delivery_spinner.active = loading;
            },
            
            _toggleAddressesLoading: function(loading) {
                this.$.addresses_spinner.active = loading;  
            },


            toggleLoading: function (loading) {
                var showAsLoading;
                if (loading) {
                    this._loadingStack ++;
                }
                else {
                    this._loadingStack --;
                }
                showAsLoading = (this._loadingStack > 0);

                if (showAsLoading) {
                    this.$.orderSummary.showAsLoading();
                    this._showAsLoadingShipping(true);
                    this._toggleCartEditing(false);

                    //this.$.p4mPurchase.setLoadingState(true);
                }
                else {
                    this.$.orderSummary.showAsLoaded();
                    this._showAsLoadingShipping(false);
                    this._toggleCartEditing(true);
                    //this.$.p4mPurchase.setLoadingState(false);
                }

            },

            _toggleCartEditing: function(allowEditing) {
                //zzzzzz
                this.$.cart.toggleEditing(allowEditing);

            },

            updateP4mCart: function (callback) {
                //console.log("updateP4mCart():", new Error().stack);
                //Send changes to P4M
                if (!callback) callback = function () { };
                /*if (this.updating) {
                    callback(null);
                    return;
                }*/
                console.log('updateP4mCart()');
                this.updating = true;
                try {
                   
                    var self = this;
                    var cartMessage =
                    {
                        "SessionId": this.sessionId,
                        "ClearItems": (!this.cartData.id), //true, // are we always replacing the whole cart? or ClearItems = this.cartData.Id === null; ??
                        "Cart": this.cartData
                    };

                    this.toggleLoading(true);
                    this.$.p4mCheckoutApi.call('postCart', null, cartMessage, function (err, data) {
                        self.updating = false;
                        if (err) {  
                            //This is a workaround. Need to either stop the double-post, or fix the 404 response to them.
                            /*console.warn('An error occurred while updating ParcelForMe:', err);
                            console.log('Stack:', new Error().stack);
                            self.onRemoteCartData.bind(self)({Cart:self.cartData}, callback);  //TODO: Fix double-post error causing 404 in P4M back end, so we can stop suppressing errors here*/

                            callback(err);
                        }
                        else {
                            self.onRemoteCartData.bind(self)(data, callback);
                        }
                    });
                }
                catch (e) {
                    this.updating = false;
                }


                
            },
            //lastSelectedAddrId: '', // record the last selected address for switching between drop points and delivery addrs

            onRemoteCartData: function (data, callback) {
                console.log('onRemoteCartData()');
                this.toggleLoading(false);
                if (!data.success) {
                    console.error(data.error);
                    callback(data.error)
                }
                else {
                    
                    if (!data.cart || !data.cart.items || data.cart.items.length === 0) {

                        window.location.reload(true);
                    }                  
                    else {
                        this.cartData = data.cart;
                        this.isNew = data.isNew;
                        /*var address = this.getAddressById(this.cartData.AddressId);
                        if (address && address.AddressType == "Address") {
                            this.lastSelectedAddrId = data.Cart.AddressId;
                        } */                                                     
                    }
                    callback(null);
                }                                     
            },

            /*
            onCartData: function (data, callback) {
                this.toggleLoading(false);
              
                if (data.Success) {
                    this.cartData = data.Cart;
                    callback(null, this.cartData);
                }
                else {
                    console.error(data.Error);
                    callback(data.Error);
                }
                
                //this.$.p4mPurchase.updateUi();
            },*/

            onCartItemsChange: function (e) {
                console.log('p4m-checkout: onCartItemsChange()');//, JSON.stringify(e));
                //If this is a valid change record,
                var beforeHash = JSON.stringify(e.base);
                var afterHash = JSON.stringify(e.value);
                if (e.path && beforeHash !== afterHash ) {
                    //Start timer, then send changes.
                    //If more changes are detected while the timer is active, reset the timer.
                    console.log("onCartItemsChange: Preparing to send cart changes");
                    if (this._changeTimer) window.clearTimeout(this._changeTimer);
                    this._changeTimer = window.setTimeout(this.sendCartItemChanges.bind(this), 2000);
                }
                else
                {
                    console.log("onCartItemsChange: No cart changes");
                }
            },

            //Take data from shipping selector representing selected shipping options
            //For example output, see gfs-checkout event selectedservicechanged
            //WARNING: Nothing in this function should send messages to the shipping selector or an endless feedback loop will ensue!
            currentService: {},
            updateShippingService: function (data, callback) { //service, shipping, expDeliveryDate, collectPoint) {
                var self = this;
                if (!callback) {
                    throw "updateShippingService(): No callback";
                }
                //if (this.updatingShipping) {
                if (false) {
                    callback(null);
                }
                else {
                    this.updatingShipping = true;
                    //If nothing has changed, exit
                    if (this.currentService.shipping === data.shipping &&
                        this.currentService.collectionPoint === data.collectionPoint &&
                        this.currentService.service === data.service &&
                        this.currentService.serviceId === data.serviceId &&
                        this.currentService.expDeliveryDate === data.expDeliveryDate) {
                        console.warn("updateShippingService(): Nothing has changed")
                        this.updatingShipping = false;
                        callback(null);                       
                    }
                    else {
                        var addr = this.consumerData.addresses.find(a => a.id === this.cartData.addressId);
                        console.log("update shipping addr: ", addr);
                        var shippingDetails = { 'service': data.service, 'amount': data.shipping, 'dueDate': data.expDeliveryDate, 'address': addr };
                        // got new shipping details so we need to get updated tax from the host
                        this.$.localApi.call('updShippingService', null, shippingDetails, function (err, cartTotals) {
                            if (err) {
                                console.error("localApi updShippingService error: ", err);
                                callback(err);
                            }
                            else {
                                this.currentService = data;
                                self.set('cartData.carrier', data.carrier);
                                self.set('cartData.shippingAmt', data.shipping);
                                self.set('cartData.serviceName', data.service);
                                self.set('cartData.serviceId', data.serviceId);
                                self.set('cartData.dropPointId', data.collectionPoint);
                                self.set('cartData.expDeliveryDate', data.expDeliveryDate);
                                self.set('cartData.tax', cartTotals.tax);
                                self.set('cartData.total', cartTotals.total);
                                if (data.collectionPoint) {
                                    self.selectCollectPoint(data.provider, data.providerId, data.collectionPoint, data.deliveryAddress, function (err) {
                                        self.updateP4mCart(function (err) {
                                            self.updatingShipping = false;
                                            callback(err);
                                        });
                                    });
                                }
                                else {
                                    self.selectDeliveryAddress(data.deliveryAddress.id, false /*Not updating GFS*/, function (err) {
                                        self.updateP4mCart(function (err) {
                                            self.updatingShipping = false;
                                            callback(err);
                                        })
                                    });
                                }
                            }
                        });
                    }
                }

            },


            selectCollectPoint: function (providerName, providerId, collectPointId, collectPointAddress, callback) {
                if (!callback) callback = function () { };
                var self = this;
                var result;
                if (!collectPointId) {
                    console.error("No collectPointId");
                    if (callback)
                        callback();
                    return;
                }
               
                var existingDropPoint = this.$.addressList.getDropPointById(collectPointId);
                if (!existingDropPoint || existingDropPoint.unsaved) {
                         
                    var directions = collectPointAddress.directions ? collectPointAddress.directions.split("]").pop() : "";
                    var prefOrder = this.consumerData.addresses.length || 1;
                    var address =
                    {
                            "id": this.sessionAddressId,
                            "addressType": "Collect",
                            "label": providerName,
                            "companyName": directions,
                            "street1": collectPointAddress.addressLines[0] || "",
                            "street2": collectPointAddress.addressLines[1] || "",
                            "city": collectPointAddress.town,
                            "postCode": collectPointAddress.postCode,
                            "state": collectPointAddress.county,
                            "country": collectPointAddress.country,
                            "countryCode": collectPointAddress.countryCode,
                            "phone": collectPointAddress.phone,
                            "latitude": collectPointAddress.coordinates.latitude,
                            "longitude": collectPointAddress.coordinates.longitude,
                            "dropPointProviderId": providerId,              
                            "dropPointId": collectPointId,
                            "collectPrefOrder": prefOrder,
                            "unsaved": true

                    };
                    self.saveAddress(address, function (err, result) {
                        //debugger;
                        self.set('cartData.addressId', result.address.id);
                        self.notifyPath('cartData.addressId');
                        self.notifyPath('consumerData.addresses');
                        callback(err);
                    });
                            
                }
                else {
                    //TODO: Replace with selectDeliveryAddress?
                    this.set('cartData.addressId', existingDropPoint.id); //collectPointAddress.Id;
                    this.notifyPath('cartData.addressId');
                    result = existingDropPoint;
                    callback(null);
                }
              
            },

            onPaymentComplete: function (e) {
                if (this.$.gfsCheckoutWidget) {
                    this.$.gfsCheckoutWidget._closeReq(function (err) {
                        if (!err) {
                            if (e && e.detail.redirectUrl) {
                                window.location = e.detail.redirectUrl;
                            }
                        }
                    });
                }
            },
            

            onSelectPaymentMethod: function (e) {
                var updCart = this.selectedCard !== undefined && this.selectedCard !== null;
                this.set('cartData.payMethodId', e.detail.id);
                this.selectedCard = e.detail;
                if (updCart) {
                    this.updateP4mCart();
                }
            },

            //onCardHashData: function (data) {
            //    this.set('cardTimestamp', data.Timestamp);
            //    this.set('cardMerchantId', data.MerchantId);
            //    this.set('cardHash', data.Hash);               
            //},

            onDiscount: function (e) {
                this.set('cartData.tax', Number(e.detail.tax));
                var cartDiscount = this.cartData.discounts.find((element, index, arr) => element.code === e.detail.code); //TODO: Change to bound function; arrow functions may not work in older browsers
                if (cartDiscount) {
                    //console.log("Added existing discount")
                    if (cartDiscount.description !== e.detail.description ||
                        cartDiscount.amount !== e.detail.amount ||
                        cartDiscount.code !== e.detail.code)
                    {
                        cartDiscount.description = e.detail.description;
                        cartDiscount.amount = e.detail.amount;
                        cartDiscount.code = e.detail.code;
                        this.cartData.tax = e.detail.tax;
                        this.updateP4mCart();
                    }
                }
                else {
                    this.push('cartData.discounts',
                    {
                        description: e.detail.description,
                        amount: e.detail.amount,
                        code: e.detail.code
                    });
                    this.cartData.tax = e.detail.tax;
                    this.updateP4mCart();
                }
            },

            onDiscountDelete: function (e, code) {

                var item = this.cartData.discounts.find((element, index, arr) => element.code === code);
                if (item) {
                    item.amount = 0;
                    item.description = "Deleted";
                    this.cartData.tax = e.detail.tax;
                    this.updateP4mCart();
                    this.$.localApi.call('removeDiscountCode', null, {"discountCode": code}, null);

                }
            },

            onGotNewCard: function(){
                 this._getConsumer();
            },

            onSelectAddressFromList: function (e) {
                /*if (e.detail.isDelivery && self.cartData.AddressId != e.detail.id) {
                    this.selectDeliveryAddress(e.detail.id, function (err) {
                        if (err) {
                            console.error("onSelectAddressFromList():", err);
                        }
                    });
                }*/


                //TODO: Must set billing address etc
                var self = this;
                if (e.detail) {

                    //If changed billing address, tell P4M
                    if (e.detail.isBilling && self.cartData.billingAddressId != e.detail.id) {
                        self.set('cartData.billingAddressId', e.detail.id);
                        self.updateP4mCart();
                    }
                    //If changed delivery address, tell GFS and P4M
                    else if (e.detail.isDelivery && self.cartData.addressId != e.detail.id) {
                        self.selectDeliveryAddress(e.detail.id, true, function (err) {
                            if (err) {
                                console.error(err);
                            }
                        });                     
                    }
                }
            },

            //TODO: Take an extra parameter: send to GFS
            //This allows two-way binding without feedback loop
            selectDeliveryAddress: function (addressId, sendToGfs, callback) {
                var self = this;
                var address = this.getAddressById(addressId);
                if (!address) {
                    callback("No such address");
                    //return false;
                }
                else {
                    //Send to GFS Checkout and await shipping event
                   

                    //If this is a user-initiated address change, we need to tell GFS and get new shipping details back (via onGfsServiceChanged)
                    if (sendToGfs) {
                        
                        //alert('TODO: Ask GFS Checkout for new details');
                        
                        this.$.gfsCheckoutWidget.selectFavAddress(addressId, true, function(err) {
                            self.set('cartData.addressId', addressId); //This allows the address UI to update
                            self.notifyPath('cartData.addressId');
                            callback(null, address);
                        });
                    }
                    else {
                        this.set('cartData.addressId', addressId); //This allows the address UI to update
                        this.notifyPath('cartData.addressId');
                        callback(null, address);
                    }
                    //callback(null, address);                
                }

            },

            onAddAddress: function (e) {
                this.onUpdateAddress(e);
                /*, function (result) {
                    if (result) {
                        e.detail.markAsBilling();
                    }
                });*/
            },

            saveAddress: function (address, finalCallback) {
                if (!address.addressType) {
                    address.addressType = 'Address';
                }
                var postData =
                {
                    "Address": address,
                    "isPrefDeliveryAddr": false,
                    "isBillingAddr": false
                };
                var self = this;
                var result = null

                var existingAddress = this.getAddressById(address.id);
                if (existingAddress) existingAddress.id = ""; //TODO: Remove this item, or replace it
                this.push('consumerData.addresses', address);

                async.series(
                    [
                        function _postAddress(callback) {
                            self.$.p4mCheckoutApi.call("postAddress", null, postData, function (err, data) {
                                result = data;
                                address.id = result.address.id;
                                self.$.gfsCheckoutWidget.setFavAddresses(self._getPreferredAddresses())

                                callback(err);
                            });
                        },
                        
                        //function _getConsumer(callback) {
                        //    callback(null, result)
                        //},
                        function _selectAddress(callback) {
                            self.selectDeliveryAddress(result.address.id, true, function(err, data) {
                                //  result = data;
                                callback(err);
                            });
                        }


                    ],
                    function(err) {
                        finalCallback(err, result);
                    }
                )
            },

            onUpdateAddress: function (addressElement) {
                // here we're adding or updating an address only, not setting a default value on the consumer at this stage

                this._toggleAddressesLoading(true);

                var self = this;
                this.saveAddress(addressElement.detail.addressData, function (err, result) {
                    if (err) {
                        self._toggleAddressesLoading(false);
                        throw err;
                    }
                    else {
                        addressElement.detail.addressData.id = result.address.id;
                        self._toggleAddressesLoading(false);

                    }
                });

            },
            /*
            preselectDeliveryMethod: function () {
                //Select delivery details based on selected address and user's preferences
                if (!this.consumerData) throw "No consumer data"
                else if (!this.cartData) throw "No cart data";

               
                //this.consumerData.PreferSoonestDelivery = true; //TODO: Remove. This is just here for testing.
                //Rather than opening a page, let's handle this directly.

                if (this.consumerData.PreferSoonestDelivery) {
                    if (this.$.gfsCheckoutWidget) {
                        //this.$.gfsCheckoutWidget.showPage_Calendar(true);
                        this.$.gfsCheckoutWidget._preselectForCalendar();
                    }
                }
                else {
                    if (this.$.gfsCheckoutWidget) {
                        this.$.gfsCheckoutWidget._preselectForStandard();
                        //this.$.gfsCheckoutWidget.showPage_Standard(true);
                    }

                }
               

            },
*/
  

            selectPreferredAddress: function (callback) {
                //If there is a preferred delivery address, select that.
                //PRECONDITION: Consumer data and Cart data exists
                console.log('selectPreferredAddress');
                if (this.consumerData.prefDeliveryAddressId) {
                    this.selectDeliveryAddress(this.consumerData.prefDeliveryAddressId, false, callback);
                }
                else {
                    callback("No preferred address");
                }
            },

            _getPreferredDropPoints: function() {
                return this.consumerData.addresses         
                    .filter(function (item) { return (item.addressType == "Collect" && item.latitude && item.dropPointId) })
                    .map(p4mDroppointToGfsDroppoint);
            },

            _getPreferredAddresses: function (maxItems) {
                var preferredAddressId = this.consumerData.prefDeliveryAddressId;
                return this.consumerData.addresses
                    .filter(function (item, i) { return (item.addressType == "Address") }) //Only addresses, not droppoints
                    .sort(function (a, b) { if (a.id == preferredAddressId) { return -1; } else { return 1 } })
                    .filter(function (item, i) { return (i < (maxItems || 99)) }) //Up to 99 addresses                   
                    .map(p4mAddressToGfsAddress);
            },

            onGfsServiceChanged: function (e) {
                if (this.initialising) {
                    console.warn('onGfsServiceChanged(): not updating while initialising');
                    return;
                }
                else {
                    console.log("p4m widget: onGfsServiceChanged():", e);
                    this.triggerChangeIndicator();
                    this.updateShippingService(e.detail, function () { console.log("onGfsServiceChanged: updateShippingService complete")});
                }
            },

            triggerChangeIndicator: function() {

                this.set("_changeIndicatorClass", "not_changed");
                window.setTimeout(function(){this.set("_changeIndicatorClass", "change")}.bind(this), 10);
                

            },

            onGfsServicePreselect: function (e) {
                this.updateShippingService(e.detail, function () { console.log("onGfsServicePreselect: updateShippingService complete") });
            },

            //The selected service wasn't available, so choose a default
            onGfsNoService: function (e) {
                // this.preselectDeliveryMethod();
                console.error('No GFS service');
            },

            onGfsSessionExpiry: function (e) {
                console.log("GFS Checkout session expired");
                if (this.onSessionExpiry) {
                    window[this.onSessionExpiry]();
                }
                else
                {
                    window.reload();
                }
                
            },

            getAddressById: function(id) {
                if (!this.consumerData) {
                    return null;
                }
                var foundItem = this.consumerData.addresses.find(function(item) { return item.id == id });
                return foundItem;
            },

            goToPaymentMethods: function () {
                this.selectedTab = this.Tabs.PAYMENT;
                this.$.cardList.addNewCard();
            },

            goToAddresses: function () {
                this.selectedTab = this.Tabs.ADDRESS;
                this.$.addressList.addNewAddress();
            },

            _onSelectTab: function (tab) {
                //Tab changed
                //console.log(tab);
            }
        });

        function p4mDroppointToGfsDroppoint(item) {
           var gfsAddress = {
                droppointId: item.dropPointId,
                droppointDescription: item.companyName,
                geoLocation: {
                                    
                    postCode: item.postCode,
                    addressLines: [item.companyName, item.street1],
                    town: item.city,
                    coordinates: {
                        latitude: item.latitude,
                        longitude: item.longitude
                    },
                    countryCode: item.countryCode,
                    county: "",
                    directions: ""
                },
                providerId: item.dropPointProviderId,
                providerLogo: "https://s-media-cache-ak0.pinimg.com/avatars/pelithepenguin_1453991623_140.jpg",
                providerName: item.label
            };
            return gfsAddress;

        }

        function p4mAddressToGfsDroppoint(item, defaultCountryCode) {
            var gfsAddress = {
                geoLocation: {
                    postCode: item.postCode,
                    addressLines: [item.street1],
                    town: item.city,
                    coordinates: {
                        latitude: item.latitude,
                        longitude: item.longitude
                    },
                    countryCode: item.countryCode || defaultCountryCode || 'GB',
                    county: "",
                    directions: ""
                },
                providerName: item.Label
            };
            return gfsAddress;

        }

        function p4mAddressToGfsAddress(item) {
            var gfsAddress = {
                id: item.id,
                countryCode: {
                    Code: item.countryCode || "GB",
                    Encoding: "ccISO_3166_1_Alpha2"
                },
                postcode: item.postCode || "",// "SO40 7JF", //ViewBag.InitialPostCode,
                town: item.city,
                addressLineCollection: [item.street1],
                name: item.label
            };
            return gfsAddress;

        }

        function hashThis(value) {
            //return Math.random().toString();
            return value.split("").reverse().join("")
        }
    </script>
</dom-module>
